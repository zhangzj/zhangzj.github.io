---
layout: post
title: "学习Lisp-前言小贴士"
categories: Lisp
excerpt:
tags: Lisp CommonLisp 翻译
---

* content
{:toc}

《Common Lisp 符号计算简单介绍》前言-给读者的小贴士



## 给教师的贴士

近几年，如何跟有效地向初学者介绍Lisp的经验开始慢慢被总结出来：比如哪里是难点，以及我们怎么应对。另外，有一些切换到Lisp的既定主题是必须使学生领会的，特别是变量，作用域和赋值。此处的“简单介绍”的意思已经为Common Lisp完全改变，包括了一些十分有价值的教学工具。让我介绍一些本书的Lisp标记法。

### 图形标记法

本书前两章使用盒子箭头标记法来描述原始函数和函数组合。在应付函数调用语法和何时使用引用等细节问题之前，这种标记法可以让学生建立起对于计算的基本概念，并了解三种基础的数据结构：数字，字符和列表。虽然对于富有经验的Lisp程序员来说，程序即是数据的概念有很大的好处，但与此同时，对于新手这也是产生迷惑的主要源头。盒子箭头标记法是将数据和程序在视觉上分隔开，从而排除大部分语法错误。这种标记法的另一个好处是缺少明确的变量；一个函数的输入就是函数定义外面指向进来的箭头。因为没有函数盒子标记法的计算机应用，所以前两章的学习被设计成为只需要纸和笔就可以快速学习。这种标记方法也将另一些令学生学习时会有挫败感的东西暂时隔离开来，不用马上学习一个真实计算机的机械细节，编辑表达式和应付调试器。

熟悉其他编程语言的读者可以花一分钟的时间快速浏览第一章，阅读最后的总结，然后浏览第二章学习一些基础的列表操作原语。

在第三章将会介绍标准EVAL标记法；引用的概念和具名变量的自然使用。这个时候，亲爱的读者（他或者她）想必已经迫不及待的想要扔掉纸和笔来接触一个真正的计算机了，从这里开始，将会真正进入这门令人兴奋的课程。

### 其他特点

有三个独特的特征将会首次出现在第三章；EVAL标记法，Lisp工具箱章节和Lisp数据结构的综合图形表述，包括了函数对象和字符的内部结构。

EVAL标记法展示了Lisp表达式是如何一步一步被计算出来的，函数是如何应用到参数当中的，以及变量是如何被创造和绑定。EVAL和APPLY角色不同，使用这种标记法可以清楚地用图形化的方法将变量的作用域和语句的无法变现的嵌套结构体现出来。图形化的标记法可是用读者都能记忆和使用的图形语言来阐述整个计算过程。

Lisp Toolkit章节介绍Common Lisp提供的丰富的编程辅助工具，比如DESCRIBE,INSPECT,TRACE,STEP,和调试器debugger。还有两个独立于本书的工具，他们的源代码在本书的附录A和附录B当中，也可以从发行商那里获得软盘版本。第一个工具就是SDRAW，可以用来制作cons cell简图。SDRAW是read-eval-draw学习循环的一部分，在给初学者讲解一些cons cell类型结构的时候是很有用的，特别是在讲解CONS，LIST和APPEND的区别的时候。第二个工具就是DTRACE，一个比TRACE手机更详细输出信息的追踪工具包，所以对初学者来说也更有用。

最后，Lisp数据的图形表述，特别是字符的内部结构，有字符的名字，函数，值，plist和package cells，帮助学生理解Lisp解释器的实质和字符，函数，变量和打印字符之间的区别重点。

### 后续章节的组织

第七章将会介绍Applicative Operator，在这里也会学习到语法闭包（lexical closures）。在第八章，前一版本的书里面龙的故事作为一个流行元素保留了下来，但是此处现在有一个新的设备支持，递归模板，帮助学生分析递归函数以理解递归风格的本质。考虑到一些讲师喜欢在applicatives之前讲述递归，有两章视为这种讲学顺序特别准备的。

本书前八章提倡一种清晰无副作用的编程风格。第九章讨论I/O，第十章建立一个统一的视角来看赋值（普通变量和全局变量），和有破坏性的序列操作。第十一章包含了迭代器，DO和DO*在没有明确赋值的情况下被使用在构造健壮的迭代语句。第十二章介绍结构，第十三章介绍数组，哈希表和属性列表。最后一张，第十四章介绍宏和汇编过程。期间也解释了语法和动态作用域的区别，EVAL图表清晰阐明了宏和特殊变量的语义。

### 对于简单的重视

因为Common Lisp是一门很复杂的语言，所以有一些地方我选择简化来更好的适应初学者的学习。比如1+和1-函数在本书中被删去了，因为他们的名字容易让人产生困惑。还有，本书中使用的的等于断言就是EQUAL断言，因为这是最经常使用到的等于断言，其他的诸如EQ，EQL，EQUALP和=这些断言将在进阶话题中介绍，但是并不是经常使用。在一些地方我选择写一些简单明了的函数而不是引入一个像PUSHNEW这样的模糊断言。另外我也不尝试覆盖所有最前沿的特性，例如多值和包系统。

一些人比较喜欢用Scheme作为入门课程的方言使用，因为他更加小巧，相较于Common Lisp来说。但是一个容易实用与教学的Common Lisp子集可以等同于Scheme，课程语言规模对于初学者来说并不是最首要的事情。另一个争论的焦点就是，一个确定的适合语言的风格，重用语法闭包可以使用Scheme语法更加优雅的表达出来。但是有些地方Common Lisp是优于Scheme的，比如对用户定义宏的支持，将列表和向量优雅的统一到一个序列数据类型里，对于键盘参数的实用极大的扩展了序列函数的可用性。厂商的支持和内建面向对象编程特色的结合造就了Common Lisp成为唯一的“工业强度”水准的Lisp方言。虽然本书侧重的无副作用，合适的编程方式使得Scheme狂热者们倍感亲切，但是确实是Common Lisp风格。

本书已经精心设计来迎合初学的编程人员和没有计算机背景的学生的基本需求，但是在每一章最后的可选的进阶话题提供了丰富的才来来满足对于跟高级的计算机知识有兴趣的人士。

而对于有更加进阶的需要的读者，Guy L. Steele Jr.所撰写的Common lisp:The Language将会是一本更加有用的入门读物。

对于初学者，Common Lisp：The Reference,by Franz会是一本更合适的参考书。


-----------修订更新：2016/01/03------------------
关于predicate这个词语，一开始接触到的时候，想了很久，是怎么翻译更好，因为后面很多地方要用这个概念。因为才疏学浅，不知道其实有专业的术语，叫做谓词，当时知道的话也就这样写了。但好像意思是相近的，都是判断返回布尔值，断言也有确定的这层意思，所以没有修正（其实是懒）。
