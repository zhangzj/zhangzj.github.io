---
layout: post
title: "Git 权威指南 第1篇 初识Git"
categories: git
description: Git权威指南读书笔记第一篇
tags: git
---

* content
{:toc}

Git权威指南第一篇





### 第一篇 初识Git

Git是分布式版本管理系统，区别于CVS和SVN这些集中式版本管理系统。

Git不仅可以实现个人知识的积累，还可以分享库，一大好处啊。

回顾一下版本控制的历史，而后是看看之前的CVS和SVN。

### 第一章 版本控制的前世今生

历史的车轮滚滚向前，慢慢变得厉害，于是Git出现了。

#### 1.黑暗的史前时代

史前时代是黑暗的，但是那个黑暗是秩序和工具的缺乏，而不是自然本身是黑暗的。

一开始是拷贝目录进行简单备份，多人的话就是用文件服务器进行协同，那么大家豆芽编辑的文件该怎么办？肯定和蛋疼。

2000年之前还是史前黑暗的时代，但是即使是在史前时代，也是有很好的源代码比较工具和打补丁的工具：diff和patch。

对于版本控制系统的理解：差异存储，和版本控制系统的使用：代码比价和冲突解决；

1. 用diff命令比较两个文本文件或目录的差异

```bash
$ diff -u hello world > diff.txt
```

输出的差分文件diff.txt当中，首先使用加号和减号标记原始文件和目标文件，减号开始的原始文件，加号开始的目标文件。

2. 命令patch相当于diff的反向操作

```bash
$ patch world < diff.txt
```

没有版本控制的时候，可以用diff和patch记录文件差异。

标准的diff 和patch不支持二进制文件的比较。

#### 2.CVS开启版本控制大爆发

CVS，Concurrent Versions System。并不是设计出来的，很久之前80年代，那是被实际需求给逼出来的设，实用至上。

借用单一文件版本管理工具RCS，CVS是CS设计，版本库在服务端，实际上就是RCS文件容器，每一个RCS文件保存对应文件的每一次更改历史。

#### 3.SVN集中式版本控制集大成者

Subversion在爆发式的版本控制软件兴起中出头，成了CVS的后继者。

#### 4.Git：Linus的第二个伟大作品

Linus不是不喜欢版本控制，是不喜欢集中式的版本控制，所以一开始选了一个分布式的版本控制软件Bitkeeper。

分布式版本控制的不同在于，可以不需要集中式的版本库。每个人都工作在通过克隆监理的本地版本，是自己版本库的主人，对于本地的完整版本库可以实现提交，创建branch，tag等等操作，不需要网络连接。

Git大事记：简单来说，两个月，Git就可以作为Linux的核心版本控制起作用了。到现在为止，使用Git的大型软件项目数不胜数。

### 第二章 爱上Git的理由

举一个典型应用的例子展示Git的用法，以及一些闪亮的特性。

#### 1.每日工作备份

鸡蛋放在一个篮子里肯定是有风险的，所以要做好随时的备份。首先是本地的版本库，笔记本上的。第二个是远程的内网服务器作为第二方案，内网的远程版本库还有一个镜像版本库作为镜像操作，每一次本地向内网远程推送的时候就会触发镜像备份操作，不需要手动触发。

#### 2.异地协同工作

在家里工作一天之后，先push到镜像服务器上的home版本库，不能直接推送mirror的原因是镜像版本库不能直接接收写操作。等到了公司，一天之前首先先拉回home版本库到本地。这样子基本上就是很多台电脑里面有好多备份了。

#### 3.现场版本控制

在客户现场或者在产品部署的现场进行源代码的修改，并且在修改过程中进行版本控制，就叫做现场版本控制。在修改完成后能够将修改结果，修改过程一并带走。

1. SVN的解决方案：（看上去很复杂的，然并卵，先跳过）

2. Git的解决方案：Git修改之后导出提交历史很简单。

（1）创建现场版本库。直接在需要的目录下面创建Git初始化

`$ git init`

（2）添加文件并提交

`
$ git add -A
$ git commit -m "initialized"
`

（3）为初始提交建立一个tag：v1

`$ git tag v1`

（4）开始在工作区中工作------修改文件并提交

`$ git commit -a`

（5）将初始提交开始的所有提交打包成补丁文件带走。导出的补丁文件都包含一个数字前缀，并提取提交日志信息作为文件名。

`
$ git format-patch v1..patch
0001-fix-typo-help-to-help.patch
0002-Add-I18N-support.patch
0003-Translate-for-Chinese.patch
`

（6）邮件生成的补丁文件，反正是文件怎么带走都可以。

备注：生成的patch文件都是Git扩展格式的文件，不能使用GNU的patch命令打补丁，会有错误。使用Git的命令是OK的。

#### 4.避免引入辅助目录

辅助目录就是版本控制工作需要的那些目录，SVN和CVS在每一个子目录下面都要新建辅助目录.svn目录和cvs目录。这些目录出现在Web服务器上是很危险的，最好不要。对文件搜索的结果也不是很好。

Git仅仅在顶级目录下创建辅助文件，如果.git还是很碍眼，也可以移到指定目录，然后执行git命令的时候指定参数就好额。

Git还有一个git grep命令专门优化查找。

#### 5.重写提交说明

提交的说明文字有错怎么办，没有对齐之前的格式怎么办，想要改变之前的提交说明怎么办？

1. SVN的解决方式：默认不允许更改，（然并卵，再说）

2. Git的解决方案：修改最新的提交的说明最简单，用一条命令修补提交就好；如果命令不带-m参数，就会进入提交说明编辑界面

`
$ git commit --amend
`

修改历史提交的提交说明，也可以。这要用到变基命令；修改commit-id所标识的提交说明，在弹出额变基索引文件中修改相应提交前面的动作的关键字。

`
$ git rebase -i <commit-id>^
`

#### 6.想吃后悔药

加入了不该加入的文件怎么办，简单删除也许可以，但是还是会保留在历史当中。

1. SVN的解决方案：然并卵

2. Git：每个人都是管理员：其实就是版本库的整理操作，可以使用修补提交的操作

`
$ git rm --cached winxp.img
$ git commit --amend
`

如果是历史版本，<commit-id>所标识的提交中引入的文件，要使用变基操作

`
$ git rebase -i <commit-id>^
`

执行交互式变基操作抛弃历史提交，版本库还不行，具体再看。

#### 7.更好用的提交列表

一次提交只干一件事情，完成了一个阶段性的工作，比如修了一个Bug，写了一节内容，加了一个文件之后就提交一次，如果是夯不啷当一起提交，那就不是版本控制，是备份系统了。

在一个工作区里面可能同时做好几件事情，全部修改的文件一次提交显然不合理，挑选一件事情相关的文件，然后河道一个commit里面，生成提交列表比较OK。

**Git的解决方案**

Git通过提交暂存区实现对提交内容的定制。

- 使用git add 命令将修改的内容加入暂存区，命令参数功能各不相同，-u可以将所有修改过的文件加入暂存区，-A是本地删除的文件和新增文件都登记，-p可以对一个文件内修改内容进行有选择的添加。

- 修改后的文件被登记到提交暂存区之后，可以继续修改，继续修改的内容不会被提交；除非再执行一次add命令。

- 执行git commit命令执行提交

- Git支持撤销提交，而且可以撤下任意多次

#### 8.更好的差异比较

Git支持二进制的差异比较，设定参数可以进行行比较，逐字比较 git diff --word-diff。

工作区里面修改的文件可能会有两个不同的版本：一个在提交暂存区，一个在工作区。

- 修改后的文件在执行git diff 命令时会看到修改造成的差异

- 修改后的文件通过git add 命令提交到暂存区后，再执行git diff 命令将看不到该文件的差异

- 继续对此文件进行修改，再次执行 git diff 命令会看到新的修改显示在差异中，而看不到旧的修改。

- 执行 git diff --cached 命令才可以看到添加到暂存区中的文件所做出的修改。

#### 9.工作进度保存

如果在工作区的修改尚未挖成时忽然有一个进击的任务，需要从一个干净的工作区开始新的工作。

又如果要切换到别的分支进行工作，那么如何保存当前未完成的工作进度？

Git提供了一个很方便的命令 git stash 来保存工作进度，在切换到新工作分支之前执行。工作区就会非常干净，然后就可以切换到新的分支。

```
$ git stash
$ git checkout <new_branch>
```

新的工作分支修改完毕之后，再切换回当前分支，调用git stash pop 命令则可恢复之前保存的工作进度。

```
$ git checkout <original_branch>
$ git stash pop
```

##### 10.代理SVN提交实现移动式办公

#### 11.无处不在的分页器

git命令行大法好，还有很多黑科技。git自带分页器，默认使用vi的热键进行操作：

|命令|含义|
|:-|:-|
|字母q|退出分页器|
|字母h|显示分页器帮助|
|空格|下翻一页|
|字母b|上翻一页|
|字母d和u|分别代表向下翻动半页和向上翻动半页|
|字母j和k|分别代表向上翻一行和向下翻一行|
|左箭头和右箭头|如果行太长被截断，可以使窗口内容左右滚动|
|输入/pattern|向下寻找和pattern匹配的内容|
|输入?pattern|向上寻找和pattern匹配的内容|
|字母n或者N|代表向前或者向后继续寻找|
|字母g|跳到第一行|
|字母G|调到最后一行|
|输入数字再加字母g|跳转到对应的行|
|输入!<command>|可移植性Shell命令|

如果想要设定less进行自动换行，太长不截断的话可以设定变量

```
$ export LESS=FRX
```

或者使用git配置变量来改变分页器默认的行为

```
$ git coonfig --global core.paper 'less -+$LESS -FRX'
```