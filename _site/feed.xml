<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZZJ</title>
    <description></description>
    <link>http://allenchyou.github.io/</link>
    <atom:link href="http://allenchyou.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 15 Oct 2016 22:41:24 +0800</pubDate>
    <lastBuildDate>Sat, 15 Oct 2016 22:41:24 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>学习Lisp-前言</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#common-lispa-gentle-introduction-to-symbols-computation&quot; id=&quot;markdown-toc-common-lispa-gentle-introduction-to-symbols-computation&quot;&gt;Common Lisp:A Gentle Introduction to Symbols Computation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《Common Lisp 符号计算简单介绍》前言部分&lt;/p&gt;

&lt;h3 id=&quot;common-lispa-gentle-introduction-to-symbols-computation&quot;&gt;Common Lisp:A Gentle Introduction to Symbols Computation&lt;/h3&gt;

&lt;p&gt;作者：David S. Touretzky （卡内基梅隆大学）&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;这是一本关于学习Lisp编程的书籍。在人工智能研究方面（计算机科学最为前沿的领域之一）Lisp作为标准语言被广泛应用。同时，Lisp也是一门优秀的编程入门语言。在编程入门的课程中，因为Lisp具有友好的解释器环境，丰富的数据结构，以及新手也能掌握的软件工具，使用Lisp作为教学语言的课程数量也正在增加。&lt;/p&gt;

&lt;p&gt;当我写这本书的时候，有三种类型的读者在我的考虑范围内，我来一一列举一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;正在学习编程入门课程的学生。当然可以是来自任何专业的学生，从计算机科学与技术到人类学等等。对于你们，我来定义一下题目中的“简单”的意思。没有超过算术水平的其他进阶的数学背景的人，假如你不喜欢数学，但是你也许会发现自己喜欢计算机编程。有许多例子来替代了难懂的技术术语解释，还有很多穿插在文字中的练习，答案就在附录C当中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;心理学者，语言学者，计算机学者和任何对人工智能感兴趣的人。当你开始探寻人工智能领域的时候，会发现几乎所有的研究成果都是使用Lisp完成的。大部分的Lisp著述主要针对的是计算机科学，但是我尽了最大的努力使得本书对于每一个人都是通俗易懂。本书可以成为你阅读人工智能材料的敲门砖，也可以成为核心工具的一个快速介绍。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算机爱好者。1984年之前，因为早期机型的内存过小，Lisp在个人电脑上的使用体验不是很好。但在今天的配备兆级别内存和大容量硬盘的计算机上，已经可以运行和大学里或者工业研究室里面同样高质量的工具环境，并且运行全部Common Lisp标准应用。本书的Lisp工具箱一节将会介绍Lisp的一些先进特性，比如对于人工智能编程和快速建模的生产力工具。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本书题目中所说的简单介绍贯穿Common Lisp的方方面面。Lisp从被创造已经过去了三十个年头。在过去，不仅同一种方言在不同的机器上是不兼容的，而且有同一种方言编写的程序几年后也不能在相同方言下运行，因为语言正在不断地更新。虽然开始的时候不受约束的更新是有利的，但是很快要求标准化的声音也开始渐渐地出现，所以Common Lisp就被创造出来了。Common Lisp已经成为事实上被各家计算机厂商支持的标准,现在也正在不断精炼成一个官方的标准。但是Lisp的更新是没有尽头的，标准也会周期性的更行反映在人们制作的发行版本上面。也许那个发行版的贡献者就是你。&lt;/p&gt;

&lt;p&gt;DAVID S. TOURETZKY&lt;/p&gt;

&lt;p&gt;匹兹堡，宾夕法尼亚&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/15/Preface/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/15/Preface/</guid>
        
        <category>Lisp</category>
        
        <category>CommonLisp</category>
        
        <category>翻译</category>
        
        
        <category>Lisp</category>
        
      </item>
    
      <item>
        <title>学习Lisp-前言小贴士</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;给教师的贴士&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;图形标记法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;其他特点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;后续章节的组织&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;对于简单的重视&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《Common Lisp 符号计算简单介绍》前言-给读者的小贴士&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;给教师的贴士&lt;/h2&gt;

&lt;p&gt;近几年，如何跟有效地向初学者介绍Lisp的经验开始慢慢被总结出来：比如哪里是难点，以及我们怎么应对。另外，有一些切换到Lisp的既定主题是必须使学生领会的，特别是变量，作用域和赋值。此处的“简单介绍”的意思已经为Common Lisp完全改变，包括了一些十分有价值的教学工具。让我介绍一些本书的Lisp标记法。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;图形标记法&lt;/h3&gt;

&lt;p&gt;本书前两章使用盒子箭头标记法来描述原始函数和函数组合。在应付函数调用语法和何时使用引用等细节问题之前，这种标记法可以让学生建立起对于计算的基本概念，并了解三种基础的数据结构：数字，字符和列表。虽然对于富有经验的Lisp程序员来说，程序即是数据的概念有很大的好处，但与此同时，对于新手这也是产生迷惑的主要源头。盒子箭头标记法是将数据和程序在视觉上分隔开，从而排除大部分语法错误。这种标记法的另一个好处是缺少明确的变量；一个函数的输入就是函数定义外面指向进来的箭头。因为没有函数盒子标记法的计算机应用，所以前两章的学习被设计成为只需要纸和笔就可以快速学习。这种标记方法也将另一些令学生学习时会有挫败感的东西暂时隔离开来，不用马上学习一个真实计算机的机械细节，编辑表达式和应付调试器。&lt;/p&gt;

&lt;p&gt;熟悉其他编程语言的读者可以花一分钟的时间快速浏览第一章，阅读最后的总结，然后浏览第二章学习一些基础的列表操作原语。&lt;/p&gt;

&lt;p&gt;在第三章将会介绍标准EVAL标记法；引用的概念和具名变量的自然使用。这个时候，亲爱的读者（他或者她）想必已经迫不及待的想要扔掉纸和笔来接触一个真正的计算机了，从这里开始，将会真正进入这门令人兴奋的课程。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;其他特点&lt;/h3&gt;

&lt;p&gt;有三个独特的特征将会首次出现在第三章；EVAL标记法，Lisp工具箱章节和Lisp数据结构的综合图形表述，包括了函数对象和字符的内部结构。&lt;/p&gt;

&lt;p&gt;EVAL标记法展示了Lisp表达式是如何一步一步被计算出来的，函数是如何应用到参数当中的，以及变量是如何被创造和绑定。EVAL和APPLY角色不同，使用这种标记法可以清楚地用图形化的方法将变量的作用域和语句的无法变现的嵌套结构体现出来。图形化的标记法可是用读者都能记忆和使用的图形语言来阐述整个计算过程。&lt;/p&gt;

&lt;p&gt;Lisp Toolkit章节介绍Common Lisp提供的丰富的编程辅助工具，比如DESCRIBE,INSPECT,TRACE,STEP,和调试器debugger。还有两个独立于本书的工具，他们的源代码在本书的附录A和附录B当中，也可以从发行商那里获得软盘版本。第一个工具就是SDRAW，可以用来制作cons cell简图。SDRAW是read-eval-draw学习循环的一部分，在给初学者讲解一些cons cell类型结构的时候是很有用的，特别是在讲解CONS，LIST和APPEND的区别的时候。第二个工具就是DTRACE，一个比TRACE手机更详细输出信息的追踪工具包，所以对初学者来说也更有用。&lt;/p&gt;

&lt;p&gt;最后，Lisp数据的图形表述，特别是字符的内部结构，有字符的名字，函数，值，plist和package cells，帮助学生理解Lisp解释器的实质和字符，函数，变量和打印字符之间的区别重点。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;后续章节的组织&lt;/h3&gt;

&lt;p&gt;第七章将会介绍Applicative Operator，在这里也会学习到语法闭包（lexical closures）。在第八章，前一版本的书里面龙的故事作为一个流行元素保留了下来，但是此处现在有一个新的设备支持，递归模板，帮助学生分析递归函数以理解递归风格的本质。考虑到一些讲师喜欢在applicatives之前讲述递归，有两章视为这种讲学顺序特别准备的。&lt;/p&gt;

&lt;p&gt;本书前八章提倡一种清晰无副作用的编程风格。第九章讨论I/O，第十章建立一个统一的视角来看赋值（普通变量和全局变量），和有破坏性的序列操作。第十一章包含了迭代器，DO和DO*在没有明确赋值的情况下被使用在构造健壮的迭代语句。第十二章介绍结构，第十三章介绍数组，哈希表和属性列表。最后一张，第十四章介绍宏和汇编过程。期间也解释了语法和动态作用域的区别，EVAL图表清晰阐明了宏和特殊变量的语义。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;对于简单的重视&lt;/h3&gt;

&lt;p&gt;因为Common Lisp是一门很复杂的语言，所以有一些地方我选择简化来更好的适应初学者的学习。比如1+和1-函数在本书中被删去了，因为他们的名字容易让人产生困惑。还有，本书中使用的的等于断言就是EQUAL断言，因为这是最经常使用到的等于断言，其他的诸如EQ，EQL，EQUALP和=这些断言将在进阶话题中介绍，但是并不是经常使用。在一些地方我选择写一些简单明了的函数而不是引入一个像PUSHNEW这样的模糊断言。另外我也不尝试覆盖所有最前沿的特性，例如多值和包系统。&lt;/p&gt;

&lt;p&gt;一些人比较喜欢用Scheme作为入门课程的方言使用，因为他更加小巧，相较于Common Lisp来说。但是一个容易实用与教学的Common Lisp子集可以等同于Scheme，课程语言规模对于初学者来说并不是最首要的事情。另一个争论的焦点就是，一个确定的适合语言的风格，重用语法闭包可以使用Scheme语法更加优雅的表达出来。但是有些地方Common Lisp是优于Scheme的，比如对用户定义宏的支持，将列表和向量优雅的统一到一个序列数据类型里，对于键盘参数的实用极大的扩展了序列函数的可用性。厂商的支持和内建面向对象编程特色的结合造就了Common Lisp成为唯一的“工业强度”水准的Lisp方言。虽然本书侧重的无副作用，合适的编程方式使得Scheme狂热者们倍感亲切，但是确实是Common Lisp风格。&lt;/p&gt;

&lt;p&gt;本书已经精心设计来迎合初学的编程人员和没有计算机背景的学生的基本需求，但是在每一章最后的可选的进阶话题提供了丰富的才来来满足对于跟高级的计算机知识有兴趣的人士。&lt;/p&gt;

&lt;p&gt;而对于有更加进阶的需要的读者，Guy L. Steele Jr.所撰写的Common lisp:The Language将会是一本更加有用的入门读物。&lt;/p&gt;

&lt;p&gt;对于初学者，Common Lisp：The Reference,by Franz会是一本更合适的参考书。&lt;/p&gt;

&lt;p&gt;———–修订更新：2016/01/03——————
关于predicate这个词语，一开始接触到的时候，想了很久，是怎么翻译更好，因为后面很多地方要用这个概念。因为才疏学浅，不知道其实有专业的术语，叫做谓词，当时知道的话也就这样写了。但好像意思是相近的，都是判断返回布尔值，断言也有确定的这层意思，所以没有修正（其实是懒）。&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/15/NoteToInstructors/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/15/NoteToInstructors/</guid>
        
        <category>Lisp</category>
        
        <category>CommonLisp</category>
        
        <category>翻译</category>
        
        
        <category>Lisp</category>
        
      </item>
    
      <item>
        <title>学习Lisp-来自译者的吐槽</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;译者的留言&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;现在可以公开的情报&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;参考书：&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;历史材料&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;进阶材料&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lisp&quot; id=&quot;markdown-toc-lisp&quot;&gt;其他lisp教科书&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;吐槽&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些吐槽&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;译者的留言&lt;/h3&gt;

&lt;p&gt;（WARNING:以下并非作者的原文）&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;现在可以公开的情报&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;由于篇幅和我比较懒，只翻译了正文部分，还有章节之间的练习题，章节之后的复习题，以及每一章的练习都省略了。总共14章正文。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通文中文的术语系统不是很统一，在翻译过程中对于这些概念也是一点点的进行理解，使用很多其他的语言概念来理解。function（函数还是功能）等等，都是按照学过的C系列语言来说的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这里给出的是这本书的英文版下载链接，&lt;a href=&quot;http://www.cs.cmu.edu/~dst/LispBook/&quot;&gt;原本书籍&lt;/a&gt;，可以直接下载英文版，最后的两个附录A和B有两个工具SDRAW和DTRACE的lisp源代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;练习题的答案在附录C中，还有术语解释，这本入门的lisp书真的写的很专业，专业的教科书。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来是本文的重点，作者列出的阅读书单&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;参考书：&lt;/h4&gt;

&lt;p&gt;Franz Inc., Common Lisp: The Reference. Addison-Wesley, Reading, MA, 1988.&lt;/p&gt;

&lt;p&gt;Steele, Guy L. Jr., Common Lisp: The Language. Digital Press, Burlington, MA,1984.&lt;/p&gt;

&lt;p&gt;这两本书出版的时间真的比较古老了，都是成名的好书，听说第二本是经典。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;历史材料&lt;/h4&gt;

&lt;p&gt;Barstow, David R., Shrobe, Howard, E., and Sandewall, Erik (eds.), Interactive Programming Environments, McGraw-Hill, New York, 1984.&lt;/p&gt;

&lt;p&gt;Gabriel, Richard P., ‘‘Lisp,’’ in Stuart C. Shapiro (ed.), Encyclopedia of Artificial Intelligence, volume 1, pp. 508–528, John Wiley &amp;amp; Sons, New York, 1987.&lt;/p&gt;

&lt;p&gt;McCarthy, John, ‘‘Recursive functions of symbolic expressions and their computation by machine,’’ Communications of the ACM 3(4), 184–195 (1960).&lt;/p&gt;

&lt;p&gt;McCarthy, John, ‘‘History of Lisp,’’ in D. Wexelblat (ed.), History of Programming Languages, Academic Press, New York, 1978.&lt;/p&gt;

&lt;p&gt;McCarthy, John, Abrahams, Paul W., Edwards, Daniel J., Hart, Timothy P., and Levin, Michael I., Lisp 1.5 Programmer’s Guide, 2nd ed., MIT Press, Cambridge,MA, 1965.&lt;/p&gt;

&lt;p&gt;lisp的创造者McCarthy的论文，真的是历史资料了，论文应该值得一看。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;进阶材料&lt;/h4&gt;

&lt;p&gt;Charniak, Eugene, Riesbeck, Christopher K., McDermott, Drew, and Meehan, James R., Artificial Intelligence Programming, 2nd ed., Lawrence Erlbaum Associates,Hillsdale, NJ, 1987.&lt;/p&gt;

&lt;p&gt;Charniak, Eugene, and McDermott, Drew, Artificial Intelligence, Addison-Wesley,Reading, MA, 1985.&lt;/p&gt;

&lt;p&gt;Gabriel, Richard P., Performance and Evaluation of Lisp Systems, MIT Press,Cambridge, MA, 1985.&lt;/p&gt;

&lt;p&gt;Hofstadter, Douglas R., Godel, Escher, Bach: an Eternal Golden Braid, Basic Books,New York, 1979.&lt;/p&gt;

&lt;p&gt;Keene, Sonya E., Object-Oriented Programming in Common Lisp, Addison-Wesley,Reading, MA, 1989.&lt;/p&gt;

&lt;p&gt;Winston, Patrick H., Artificial Intelligence, 2nd ed., Addison-Wesley, Reading, MA,1984.&lt;/p&gt;

&lt;p&gt;进阶是人工智能方面呢，看来很有意思的样子。&lt;/p&gt;

&lt;h4 id=&quot;lisp&quot;&gt;其他lisp教科书&lt;/h4&gt;

&lt;p&gt;Abelson, Harold, and Sussman, Gerald Jay, Structure and Interpretation of Computer Programs, MIT Press, Cambridge, MA, 1985. SICP，MIT的schme教科书。&lt;/p&gt;

&lt;p&gt;Anderson, John R., Corbett, Albert T., and Reiser, Brian J., Essential Lisp, Addison-Wesley, Reading, MA, 1987.&lt;/p&gt;

&lt;p&gt;Wilensky, Robert, Common LISPcraft, W. W. Norton, New York, 1986.&lt;/p&gt;

&lt;p&gt;Winston, Patrick H., and Horn, Berthold K. P., Lisp, 3rd ed., Addison-Wesley,Reading, MA, 1989.&lt;/p&gt;

&lt;p&gt;其他的入门教科书，略略看了一下SICP，一开始就不能直视啊，才先来看一些基础的。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;吐槽&lt;/h4&gt;

&lt;p&gt;其实和其他的语言相比，Lisp的书籍基本上都是以在线电子书的形式免费获取的，&lt;a href=&quot;http://cliki.net/Lisp%20books&quot;&gt;超级书籍列表&lt;/a&gt;,只是基本上都是英文的，中文的材料有著名的伞哥（也是国内唯一的知名lisp开发者）翻译的实用common lisp编程，已经出版了。&lt;/p&gt;

&lt;p&gt;作为一个初学者，感觉lisp的学习曲线还是很陡峭的，和其他传到国内的编程语言命运差别很大，好像国内的人工智能研究也没有太多关注，中文社区也没有很多，中文资料几乎没有，高校里面也没有打算教，微博上的相关大V也没有多少，各个geek网站也没有关注，我看了一些资料和大家的论调之后，想可能lisp真的是一种已经淘汰的语言。可能不止没有钱途，更加连前途都没有，对初学者没那么友好的结果就是没有新鲜血液流入，最后悔慢慢凋零，说实话，一开始写超过十行的程序，括号就已经开始凌乱了。&lt;/p&gt;

&lt;p&gt;说起来也许是很中二的，一直深信在发展的时候，无论是科技发展和社会发展，人工智能一定是最终的工具，或者说其中的一步，很多的科幻电影都会描述机器有了自我意识的时候会发生什么，就像机器有了生命，有了真正的自我，而不是一个先进的算法，可以自己思考，自己做出判断，甚至有感情，由道德，懂得幽默，会讲笑话的智能。当然形式不一定是机器人，人形的机器，而只是智能。&lt;/p&gt;

&lt;p&gt;一条路被开辟出来的时候，无论这条路是宽还是窄，人多还是人少，后来的人都会走过前人走过的地方，最后在路的尽头或者某一块，用自己的时间和精力来拓展一块。也就是站在巨人的肩膀上看世界，虽然有时候可能都看不到路的尽头。&lt;/p&gt;

&lt;p&gt;Lisp，人工智能，prolog，或许这就是前人走过的路，那就在旧的路上看看尽头，走到世界的尽头，也挺有意思的。&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/15/FromTranslator/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/15/FromTranslator/</guid>
        
        <category>Lisp</category>
        
        <category>CommonLisp</category>
        
        <category>翻译</category>
        
        
        <category>Lisp</category>
        
      </item>
    
      <item>
        <title>学习Lisp-第二章-列表-B</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;第二章 列表&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#cons&quot; id=&quot;markdown-toc-cons&quot;&gt;2.11 构造（CONS）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#cons-1&quot; id=&quot;markdown-toc-cons-1&quot;&gt;2.11.1 CONS函数和空列表&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#cons-2&quot; id=&quot;markdown-toc-cons-2&quot;&gt;2.11.2 使用CONS函数创造嵌套列表&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#cons-3&quot; id=&quot;markdown-toc-cons-3&quot;&gt;2.11.3 CONS函数直接创造列表&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#conscarcdr&quot; id=&quot;markdown-toc-conscarcdr&quot;&gt;2.12 CONS函数和CAR/CDR的互相转换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;2.13 列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;2.14 替换一个列表中的首元素&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#list&quot; id=&quot;markdown-toc-list&quot;&gt;2.15 LIST断言&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;复习题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;本章涉及的函数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;第二章进阶话题&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;2.16 列表的单数算术运算&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;2.17 非列表单元结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;2.18 循环列表&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;2.19 非列表内存结构的长度&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《Common Lisp 符号计算简单介绍》第二章 列表 下半部分&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;第二章 列表&lt;/h2&gt;

&lt;h3 id=&quot;cons&quot;&gt;2.11 构造（CONS）&lt;/h3&gt;

&lt;p&gt;CONS函数是创造内存单位的函数，这个函数接受两个输入，返回一个指向内存单元的指针，这个创造出来的内存单元。CAR指向第一个输入，CDR指向第二个输入。函数名CONS就是construct构造的缩写。&lt;/p&gt;

&lt;p&gt;假如我们用括号表达式来解释CONS函数的行为，那就是在列表之前插入了一个元素。例如把字符串A插入到列表(B C D)的首部&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekzhpxjgarj209c02t0sk.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另一个例子：把字符串SINK插入到列表(OR SWIM)中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekzhsjsn4mj20bj035745.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有一个函数GREET（问候）是把字符串HELLO插入到任何对象之前形成列表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekzhuyqmklj20k50cxq3d.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了切实理解CONS的运行，最好使用内部表示法来思考。CONS是一个极其简单的函数，他并不知道“在列表的前面”是具体什么意思，（请注意，在计算机内部是没有圆括号标示的）。所有的CONS所做的事情就只是创造一个新的内存单元。但是计入第二个输入是一个列表，长度为n，那么新的列表将会是长度为n+1。请看图2-1，CONS函数返回一个内存单元的指针，在效果上看，返回的是一个长度加1的列表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2c06q2qej20k20mcjse.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cons-1&quot;&gt;2.11.1 CONS函数和空列表&lt;/h4&gt;

&lt;p&gt;既然已知NIL是空列表，那么一个对象和NIL作为输入，CONS函数输出的就是一个单元素列表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2c3zbvqpj209102y3yc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过观察结果的内部表示可以确认，结果的CAR是指向字符串FROB，CDR是指向NIL，所以CONS函数实际上是创造了一个列表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2c7gt3ojj205202qt8i.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有另外一个例子，可以吧FROB用NIL来替代。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2c9whk6zj2082033jr7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果是从打印表达来看的话，将某个对象和NIL组合在一起，其实就是加上了一层圆括号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2cbwgvtrj20cx03e3ye.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cons-2&quot;&gt;2.11.2 使用CONS函数创造嵌套列表&lt;/h4&gt;

&lt;p&gt;CONS函数的第一个输入如果是一个非空列表，它的返回结果将是一个多层的嵌套列表，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2cg62d9ej20dr06bq30.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cons-3&quot;&gt;2.11.3 CONS函数直接创造列表&lt;/h4&gt;

&lt;p&gt;假设我们现在想要直接创造列表(FOO BAR BAZ)。我们会先将字符串和NIL组合创造出列表(BAZ)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2cl2seooj207l02xt8j.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后再把BAR加上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2cldc74gj20900383yd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后加上FOO：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2cldpeeuj20bp038glh.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;类似于下图的模型，我们直接创造了列表(FOO BAR BAZ)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2cpf8o45j20es07nglm.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果从横向看这个图，那么就会发现这和列表(FOO BAR BAZ)的内存结构图一模一样，这也是给出了一个线索，为什么CONS函数和内存单元（cons cell）使用了相同的名字。
#### 练习&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.18 写一个双输入函数，使用CONS函数将他们组成一个列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conscarcdr&quot;&gt;2.12 CONS函数和CAR/CDR的互相转换&lt;/h3&gt;

&lt;p&gt;一个有趣的现象就是CONS函数和CAR/CDR之间的相互转换。给出一个函数x。x的CAR和CDR组合在一起就是x本身。例如，列表x的CAR是字符串A，x的cCDR是列表(E I O U)，那列表x肯定就是(A E I O U)。&lt;/p&gt;

&lt;p&gt;这种互相转换的形式还可以使用等式来表达。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = CONS of (CAR of x) and (CDR of x)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然而，这种转换关系只有在，列表非空的情况下成立。当x是NIL的时候，列表x的CAR和CDR也是NIL。假如我们将x的CAR和CDR部分组合在一起，也即是NIL和NIL组合，产生的不是空列表NIL而是列表(NIL)。这就是意味着，他们是相同的，但是就我们所知，NIL和(NIL)是不同的。这也提醒我们NIL并不是一个寻常的列表。现在的既有现实就是，这个互换性只支持非空列表，也就是至少列表中需要含有一个元素。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.13 列表&lt;/h3&gt;

&lt;p&gt;在Lisp中，把一些元素组合成一个列表是很普遍的操作，LIST函数就是实现这个功能的内建函数。LIST函数接受任何数量的输入，并把它们结合成一个列表作为结果输出。LIST函数构造了一个以NIL为结束的内存单元链条，元素数量就是输入的数量。图片2-2显示了这一个具体过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2erapd50j20ab035dfp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回顾CONS函数总是构成一个新的内存单位，行为是将第一个输入加入到第二个输入当中。而LIST函数是完全创造一个新的内存单元链条。在括号表达式中，表现为用圆括号将所有输入包括进来，无论输入的数目是多少。LIST函数的输出结果总是比输入要多一层的括号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2evj9rnvj207n035q2r.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LIST函数分配三个新的内存单元：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2fgjczw1j20af034jr7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填充CAR的指针&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2fgxdxjoj20ag031jr8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填充CDR指针并形成链条，返回第一个内存单元的指针
&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2fgxojbfj20f1047mx3.jpg&quot; alt=&quot;&quot; /&gt;
图片2-2 LIST函数如何形成一个新的列表
&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2fm1k975j209002umwz.jpg&quot; alt=&quot;&quot; /&gt;
LIST函数的工作实际上是构成一个新的内存单元链条，CAR部分是指向各个输入的指针，而输出的结果就是第一个内存单位的指针。下面是一些例子：
&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2freul0uj208v0fwdg1.jpg&quot; alt=&quot;&quot; /&gt;
下面是一个叫做BLURT函数的定义，接受两个输入并且使用它们填充句子中的空缺。
&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2fu2fda6j20ah06edft.jpg&quot; alt=&quot;&quot; /&gt;
BLURT函数举例：
&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2fvb2l0oj20b203bjr9.jpg&quot; alt=&quot;&quot; /&gt;
我们现在来看看CONS函数和LIST函数的区别，CONS函数构造的是一个内存单元，而LIST函数构造的是一个新的内存单元链条，并且不论输入数量。
&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2fy3nnpxj20fa09pmxa.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2fy4227gj20f2031jra.jpg&quot; alt=&quot;&quot; /&gt;
理解LIST函数的另一个方式就是将其看做CONS函数的级联调用。
&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2g5xuv7qj20kg0cx74q.jpg&quot; alt=&quot;&quot; /&gt;
#### 练习&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.19 写出下列计算过程的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2g734n1wj20ag0g00sy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.14 替换一个列表中的首元素&lt;/h3&gt;

&lt;p&gt;假设我们想要用字符串WHAT来替换一个列表中的首元素。首先REST函数可以被用来提取不包括首元素在内的子列表，然后CONS函数再把字符串WHAT加入到首元素的位子上。这样一个自定义的函数被称为SAY-WHAT。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2gf2g7flj20ck07tq30.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2gg5yox0j20dq0373ye.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(TAKE A NAP)输入REST函数之后输出的结果是(A NAP)。将字符串WHAT组合到和这个列表中就得到了新的列表(WHAT A NAP)。&lt;/p&gt;

&lt;p&gt;如所见，SAY-WHAT函数并不是真的替换了列表的首元素。所做的事情是产生了一个新的列表然后将生成的内存单元的CDR指针指向了这个列表。最后的结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2gl59mjyj20fg06rt8q.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.20 下列计算过程返回的结果是？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2gmlexcrj20cy0jft92.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2.21 定义一个四输入函数，返回一个两元素的嵌套函数。第一个元素师前两个输入构成的列表，第二个元素是后两个输入构成的列表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.22 假设我们要定义一个叫做DUO-CONS 的函数，在列表之前加上两个元素。请注意一般的CONS函数式在列表前面加上一个元素。DUO-CONS函数将会接受三个输入。例如，假设输入是字符串PATRICK，字符串SEYMOUR，还有列表(MARVIN)，那么DUO-CONS函数的输出将会是列表(PATRICK SEYMOUR MARVIN)。请定义这样一个函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.23 TWO-DEEPER函数的作用是给输入加上两层括号。例如，输入是TWO-DEEPER，输出是((TWO-DEEPER))，输入是(BOW WOW)输出就是(((BOW WOW)))。请使用LIST函数来定义这个TWO-DEEPER函数。并使用CONS函数来定义另一个版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.24 什么内建函数可以将字符串NIGHT从列表(((GOOD)) ((NIGHT)))中提取出来？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;list&quot;&gt;2.15 LIST断言&lt;/h3&gt;

&lt;p&gt;假如输入是列表LISTP输出T，如果不是列表就输出NIL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2h6f2811j20ko0913yl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果输入是内存单元（cons cell）CONSP断言就会返回T。CONSP几乎等同于LISTP，只是在对待NIL作为输入的时候有所不同。NIL是一个列表，但却不是一个内存单元。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2ha3rcd5j20be09tdfu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果输入不是一个内存单元，那函数ATOM就会返回T。函数ATOM和函数CONSP刚好是相对立的，同一个输入的情况下，一个返回T的同时，另一个必定返回NIL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2hee93iij20ho0e80sy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;单词ATOM来源于希腊语atomos，意思是不可分割的，原子。数字和字符串因为不能再拆分所以是不可分割的，而非空列表不是不可分割的。FIRST函数和REST函数就可以拆分他们。&lt;/p&gt;

&lt;p&gt;NULL断言在输入是NIL的情况下返回T。这个行为和NOT断言是一样的。根据惯例，Lisp程序员在准备逻辑操作的时候使用NOT，比如把true改成false，false改成true。检测一个列表是不是为空的时候使用NULL。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;本章介绍了在Lisp中最丰富的数据类型，列表。列表同时具有打印形式和内部存储形式，列表可以包括字符串，数字或者其他列表作为元素。&lt;/p&gt;

&lt;p&gt;我们可以使用CAR或者CDR（FIRST和REST）来把列表拆分，也可以使用CONS函数和LIST函数来构造列表。LENGTH函数可以计算在列表中的元素数目，这个数目也就是列表的顶层元素的个数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CAR和CDR的要点在于：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;CAR和CDR只接受列表作为输入&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;FIRST函数和REST函数与CAR和CDR相同。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SECOND和THIRD等同于CADR和CADDR.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Common Lisp提供了C____R的内建函数，其中间由四位组合。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串NIL也有一些重要事项：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;NIL是一个字符串，在Lisp中是表达no或者false的唯一手段。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;NIL是一个列表，空列表，长度是0。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;NIL在Lisp中式唯一一个既是字符串又是列表的对象。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;NIL是一个内存单元链条的结束标记。当列表以打印形式来体现，按照惯例，链条的结尾的NIL是被省略的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;NIL和()在内部形式中式等同的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;NIL的CAR和CDR被定义为NIL。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;复习题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2.25 为什么cons cell和CONS会有相同的名字？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.26 下面两个函数在给予相同输入(A B C)的时候会怎样操作？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2hyfq98zj20jh0ftdgb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2.27 在什么时候，一个列表包含的内存单元要比这个列表所有的元素还多？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.28 试过只是使用CAR和CDR，有没有可能定义出一个函数来返回列表的最后一个元素，无论这个列表有多长？请解释。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;本章涉及的函数&lt;/h3&gt;

&lt;p&gt;列表函数：FIRST,SECOND,THIRD,FOURTH,CAR,CDR,CONS,LIST,LENGTH.&lt;/p&gt;

&lt;p&gt;CAR和CDR的组合：CADR,CADDR等等。&lt;/p&gt;

&lt;p&gt;断言：LISTP,CONSP,.ATOM,NULL。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;第二章进阶话题&lt;/h2&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.16 列表的单数算术运算&lt;/h3&gt;

&lt;p&gt;列表是可以用在单数（位数是1）算术运算上的。在这个系统中，数字式被表示成标记符号组成的列表，就像一个在监狱中的犯人在牢房的墙上刻下记号来数过去了几天。数字1就是一个标记符号，2就是两个标记符号，以此类推。数字0被标记为没有标记。我们不考虑附属的情况。&lt;/p&gt;

&lt;p&gt;假设使用x作为标记符号，我们可以将数字写成标记符号x组成的列表。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0就是NIL
1就是(x)
2就是(x x)
3就是(x x x)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;鉴于已经定义的单数，我们可以研究一下，列表操作函数来操作他们。REST函数在数字钟减去1.就像SUB1函数定义的一样，从自然数中减去1，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2j0aeclaj20ak03w744.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1减去1的情况就是得到0：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2j1diq3sj20a4045dfo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是0减去1的道德并不是-1，请注意我们定义的个位数运算时没有负数的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2j34xuoij209503p744.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LENGTH函数可以讲这个标记列表转换成为自然数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1el2j4pdj9rj20c203x0sl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不是所有列表原始函数都能在一元运算中使用。CAR函数不可以。然而，将非原始函数运用在一元运算中是可能实现的。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.29 写一个函数UNARY-ADD1来给个位数加1、&lt;/li&gt;
  &lt;li&gt;2.30 CDDR会对艺一元数字有什么操作？&lt;/li&gt;
  &lt;li&gt;2.31 写一个UNARY-ZEROP断言。&lt;/li&gt;
  &lt;li&gt;2.32 写一个UNARY-GREATERP断言，功能类似于&amp;gt;断言。&lt;/li&gt;
  &lt;li&gt;2.33 CAR也可以被看做一个一元数字的断言。不是返回T或者NIL，CAR返回的是X或者NIL。请注意，X或者其他任何非NIL的对象在Lisp中都被看做true。当一元数字输入的CAR函数的时候会有什么问题？&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-10&quot;&gt;2.17 非列表单元结构&lt;/h3&gt;

&lt;p&gt;一个严格意义上的列表是用NIL来作为结尾的。作为管理，括号表达式的时候是省略括号的。所以下列表达就能被写成(A B C)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2jermdx1j20f103bgli.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有另一种内存单位结构并不是严格意义上的列表，因为在结尾并不是指向NIL。这样的结构该如何用括号表达式来表达呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2jh1jktuj20es03m747.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开始打印一个列表的括号表达式的时候，Lisp最先从最左边的括号开始打印，然后依次打印每个元素，并且用空格分割开来。加入这个列表是用NIL来作为结尾，Lisp将会用右括号来结尾，如果不是NIL来结尾，在打印右括号之前先打印一个空格，一个小数点，再来一个空格，然后是一个原子对象结束。这样的列表称作点式列表(dotted list)，并不是严格意义上的列表。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(A B C . D)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到现在为止，产生不以NIL为结尾的内存结构的方法只有通过CONS函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1el2jn6ii4ej209g03sjr8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CONS函数的结果被称为点对（dotted pair）。括号表达式写成（A . B）,内部形式是这样&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2kag9qc9j204v03bmwy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个点对是一个CDR指向不为NIL的内存单元。点列表(A B . C)包括两个内存单元，构成如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2kteft1tj20eq06odft.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在内部形式中，(A B . C)是这样&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2kuykjc8j209x03hjr8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然LIST函数是比CONS函数更加方便的构成列表的方法，但是LIST函数只能构成一般的列表，也就是NIL结尾的列表，不能构成点式列表，点式列表就必须用到CONS函数。
#### 练习&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.34 写一个表达式，来构造列表(A B C . D)，使用CONS函数的级联调用。&lt;/li&gt;
  &lt;li&gt;2.35 画出点式列表((A . B) (C . D))的内部表达，写一个表达式来狗仔这个列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;2.18 循环列表&lt;/h3&gt;

&lt;p&gt;点式列表看上去可能有点奇怪，但是更奇怪的也是有的，就是要介绍的循环列表（circular list）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1el2l4svodwj20ex04naa0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果计算机想要展示上图中的列表，那么一些问题就可能出现，根据各个打印设备的不同有所不同，这个一会儿再讨论。计算机可能陷入没有尽头的循环当中，或者尝试打印一部分的列表，使用省略号等等：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      (A B C A B C A B ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个种方式是不正确的，因为他表现了列表包含超过十个以上的元素， 但是实际上列表只有三个元素。&lt;/p&gt;

&lt;p&gt;Common Lisp提供了完整而正确的方法来解决循环结构，使用的而方法就是以井号#为基础的，井号等位标记法（sharp-equal notation）。基本上，为了表示循环结构，我们需要一个方法，来给一个内存单元赋予一个标签，然后稍后才能再找回到这里。（例如，上图中的循环列表，第三个内存单元的CDR指向回到了第一个单元。）我们使用证书作为标签，然后这#n= 来标记一个对象，用#n#来在表达式中表示对象位置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       #1=(A B C . #1#)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-12&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.36 反驳：列表不能只用CONS函数来构造。提示：想想单元被构造起来的顺序。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更加奇怪的是下面这一个，这个内存单元的CAR是指向自己的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2mahngozj207i03yglf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果计算机想要打印这个结构，那么将会技术在一个左括号循环中。但是如果是命令打印井号等位表达式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      #1=(#1# . A)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-13&quot;&gt;2.19 非列表内存结构的长度&lt;/h3&gt;

&lt;p&gt;列表的长度是顶层层次的内存单元个数，但是列表(A B C . D)的长度是3，而不是4，同样长度的列表是(A B C)，同样也可以写成(A B C . NIL)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1el2mfe0c8dj20bl03vglg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果给出一个循环列表作为输入，例如#1=(A B C . #1#)，LENGTH函数可能返回一个值，在大部分视线中是会陷入无限循环。&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/15/Ch-02-Lists-B/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/15/Ch-02-Lists-B/</guid>
        
        <category>Lisp</category>
        
        <category>CommonLisp</category>
        
        <category>翻译</category>
        
        
        <category>Lisp</category>
        
      </item>
    
      <item>
        <title>学习Lisp-第二章-列表-A</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#lists&quot; id=&quot;markdown-toc-lists&quot;&gt;第二章 列表（LISTS）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;2.1 列表是最丰富多彩的数据类型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;2.2 列表看上去是什么样子的？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;2.3 单元素列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;2.4 嵌套列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;2.5 列表的长度&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;2.6 空列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;2.7 列表之间的相等&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#firstsecondthirdrest&quot; id=&quot;markdown-toc-firstsecondthirdrest&quot;&gt;2.8 FIRST,SECOND,THIRD和REST&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;2.9 函数操作指针&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#carcdr&quot; id=&quot;markdown-toc-carcdr&quot;&gt;2.10 CAR和CDR&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#cdr&quot; id=&quot;markdown-toc-cdr&quot;&gt;2.10.1 一个单元素列表的CDR&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;练习&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#carcdr-1&quot; id=&quot;markdown-toc-carcdr-1&quot;&gt;2.10.2 CAR和CDR的组合&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;练习&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#carcdr-2&quot; id=&quot;markdown-toc-carcdr-2&quot;&gt;2.10.3 嵌套函数的CAR和CDR&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#nilcarcdr&quot; id=&quot;markdown-toc-nilcarcdr&quot;&gt;2.10.4 关于NIL的CAR和CDR&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《Common Lisp 符号计算简单介绍》第二章 列表 上半部分&lt;/p&gt;

&lt;h2 id=&quot;lists&quot;&gt;第二章 列表（LISTS）&lt;/h2&gt;

&lt;h4 id=&quot;section&quot;&gt;2.1 列表是最丰富多彩的数据类型&lt;/h4&gt;

&lt;p&gt;Lisp这个名称是list Processor的缩写。虽然Lisp已经发展成熟很多年，但是列表依然是核心数据类型。列表的重要在于，他几乎可以表现为任何形式：集合，表格，图表，甚至英语句子。列表也可以用来表现函数，但是这个话题我们留到后续章节介绍。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.2 列表看上去是什么样子的？&lt;/h4&gt;

&lt;p&gt;每一个列表都有两个形式： 打印形式和内部的存储形式。打印形式因为简洁易懂的形式更容易被人理解。内部形式则是列表在计算机内存中真实存在的样子。我们将会用一种图形表达方法来表示内部的存储形式。&lt;/p&gt;

&lt;p&gt;在打印形式中，一个列表由一连串项目组成，以圆括号包裹形成。这些项目被统称为列表的元素。下面有一些用括号表达式来标示的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(RED GREEN BLUE)
(AARDVARK)
(2 3 5 7 11 13 17)
(3 FRENCH HENS 2 TURTLE DOVES 1 PARTRIDGE 1 PEAR TREE)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;列表的内部形式并不包括圆括号，在内存中，列表被组织称为一连串的内存单位（Cons Cells），下同中的矩形框所表示。而这些内存单位是由指针（内存地址）连接在一起，下图中的箭头表示。每一个内存单位有两个指针，其中一个指向列表的元素，比如下图中的RED，另一个指向里标的下一个内存单位。当我们谈论到“列表可能包括字符串或者数字作为元素。”的时候我们实际上是指内存单位可能包括指向字符串或者数字的指针，当然也包括指向其他单元的指针。列表(RED GREEN BLUE)在计算机内部的表现如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekwktvn56uj20eq02yt8n.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到这张图的最右边，你或许注意到，列表链的最后是由NIL来作为结束，这是Lisp当中的惯例。这也许违背了某些环境的规定，但是在大部分时候列表总是由NIL来结尾。在括号表达式中，在列表最后的NIL往往省略处理，这也是惯例。&lt;/p&gt;

&lt;p&gt;在计算机内部，实际上每一个内存单位都是一小段内存，然后人为的分成了两部分，只要足够达到储存数据指针的大小，事实上的真实数据存储在其他地方，单元中存储的只是数据的指针（内存地址）。一般来说，大部分计算机的指针是4个字节，所以每一个内存单位是8个字节。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.1 用单元格形式画出列表(TO BE OR NOT TO BE)在计算机内部的存储图示。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;2.3 单元素列表&lt;/h4&gt;

&lt;p&gt;一个字符串和一个只有一个元素的列表不是一样的。下图所示的列表(AARDVARK)，使用一个内存单位来体现。第一个单元的指针指向字符串AARDVARK，另一个指针指向NIL。所以显而易见列表(AARDVARK)和字符串AARDVARK是完全不同的对象。前者的是一个内存单元，它的指针指向后者。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekwlmkodswj205302wweb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2.4 嵌套列表&lt;/h4&gt;

&lt;p&gt;一个列表可能包含其他列表作为自己的元素。给出下面三个列表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(BLUE SKY)
(GREEN GRASS)
(BROWN EARTH)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以用另一对圆括号来把这三个列表聚合成一个列表。结果如下：（这里提示一下注意层次的重要，这是单个列表组成的列表，不是六个字符串组成的列表）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;((BLUE SKY) (GREEN GRASS) (BROWN EARTH))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们愿意的话可以把上例中的水平表示转换成垂直表示。空格和缩进并不影响列表的意思，只要圆括号和元素没有改变的话。上例中的列表也能写成这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;((BLUE SKY)
            (GREEN GRASS)
                    (BROWN EARTH))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一个元素仍然是(BLUE SKY)。用单元格表示的话就会是下图的样子，列表的三个元素就是第一层次的三个内存单元。每一个元素都是一个含有两个字符串的列表，每一个顶层单元指向一个低层次的双单元列表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekwp6lole2j20m104tdg4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;任何书写出来的括号表达式在计算机内部都有一个内存单元结构对应（如果括号匹配不错）。加入括号匹配错误。比如这个列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(RED (GREEN BLUE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;计算机不能正确生成一个相对应的内存结构，那就会返回一个错误消息。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.2 下列列表哪些是格式正确的？也就是说，哪一个是括号疲惫正确的？&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(A B (C)
((A) (B))
A B )(C D)
(A (B (C))
(A (B (C)))
(((A) (B)) (C))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2.3 画出列表(PLEASE (BE MY) VALENTINE)的盒装图。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.4 下列内存结构的括号表达式是什么？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekwprp1wvtj20gi057mxb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;2.5 列表的长度&lt;/h4&gt;

&lt;p&gt;列表的长度就是列表中元素的个数，例如，列表(HI MOM)的长度就是2。那列表组成的列表长度如何计算？一个括号表达式写就的列表，他的元素就是在第一层次的项目。例如列表 (A (B C) D)中的元素就是A，列表(B C)和D。字符B,C都仅仅是元素列表(B C)的组成部分。&lt;/p&gt;

&lt;p&gt;需要注意的是，在计算机内部是不使用括号的。从计算机的角度来看，列表(A (B C) D)包括三个元素，因为在内部的存储的形式就只有三个内存单元，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekwprp1wvtj20gi057mxb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此可见，一个列表的长度和他元素的复杂程度是没有关系的。以下列表都确实只有三个元素，虽然一些列表的元素本身是列表。三个元素已经有下划线表示出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekwqlq4ywzj20g9066jrn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原始函数LENGTH就是用来计算列表长度的函数。如果给定的输入并不是列表，而是字符串或者数字，那就会报错。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekwqppviftj20eg0bhzkf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekwqqu9587j20bs03wq2s.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.5 下列每一个列表分别含有多少个元素？&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;长度&lt;/th&gt;
      &lt;th&gt;列表&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;(OPEN THE POD BAY DOORS HAL)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;((OPEN) (THE POD BAY DOORS) HAL)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;((1 2 3) (4 5 6) (7 8 9) (10 11 12))&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;((ONE) FOR ALL (AND (TWO (FOR ME))))&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;((Q SPADES) (7 HEARTS) (6 CLUBS) (5 DIAMONDS) (2 DIAMONDS))&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;((PENNSYLVANIA (THE KEYSTONE STATE)) (NEW-JERSEY (THE GARDEN STATE)) (MASSACHUSETTS (THE BAY STATE)) (FLORIDA (THE SUNSHINE STATE)) (NEW-YORK (THE EMPIRE STATE)) (INDIANA (THE HOOSIER STATE)))&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-8&quot;&gt;2.6 空列表&lt;/h4&gt;

&lt;p&gt;没有元素的列表叫做空列表。没有内存单位，写作一对空的圆括号。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;（）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在计算机内部，空列表是用NIL来表示。这里是一个难点：字符串NIL就是空列表，那又为什么把NIL作为一个列表链的结尾呢？&lt;/p&gt;

&lt;p&gt;既然空列表和NIL是完全相同的，那么可以很自然地把NIL和（）互相置换。比如列表（A NIL B）也可以写成（A （） B）。这两者在使用上没有任何区别因为在计算机内部是完全相同的两个对象。&lt;/p&gt;

&lt;p&gt;空列表的长度是0，虽然NIL是一个字符串，但是因为NIL也是一个列表，所以作为LENGTH的输入时合法的。NIL也是唯一一个既是列表又是字符串的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekwreigyphj20ae07u0sp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.6 既然NIL和（）是可以互相替换的，那么请将左侧一列和右侧一列一一对应起来。（请注意括号的层次）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekwrjsxbhcj20d606mmx4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;2.7 列表之间的相等&lt;/h4&gt;

&lt;p&gt;如果相对应的每一个元素都是相等的，那么两个列表就被认为是相等的。看一下下面的两个列表（A （B C） D）和（A B （C D））&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekwrsxqi3pj20fv0ajmxf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这两个列表由同样的元素数量（都是三个）。但是他们不是相等的。第一个列表的第二个元素是（B C），但是第二个列表的第二个元素是B。而且这两个列表都不等于（A B C D），因为他是四个元素的。假如两个列表有着不同的元素数量，则是绝不可能相等的。&lt;/p&gt;

&lt;h4 id=&quot;firstsecondthirdrest&quot;&gt;2.8 FIRST,SECOND,THIRD和REST&lt;/h4&gt;

&lt;p&gt;Lisp提供了从列表中提取元素的原始函数。函数FIRST,SECOND,和THIRD分别返回输入的列表的第一第二和第三个元素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekwsllsxgpj20cf03ma9w.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekwsm86n69j20bz07pjrd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果输入不是列表，就会报错。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekwsx8etcfj20cw03ia9x.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;REST函数是FIRST函数的补集，REST函数会返回除了第一个元素的所有元素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekwt12g4ooj20gn07jaa4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用FIRST函数和重复使用REST函数就可以构造出我们自己的SECOND,THIRD,FOURTH等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekwt3y10x0j20e406rdfx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假如MY-SECOND的输入是(PENGUINS LOVE ITALIAN ICES)，那REST函数将会输出列表(LOVE ITALIAN ICES),，这个列表的首个首个元素就是LOVE。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekwtb83sraj20ic03h3yg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.7 当给出输入(HONK IF YOU LIKE GEESE)的时候，MY-SECOND函数的内部是如何运行的？&lt;/li&gt;
  &lt;li&gt;2.8 怎样使用一个FIRST函数和两个REST函数写一个MY-THIRD函数？&lt;/li&gt;
  &lt;li&gt;2.9 怎样使用SECOND函数写一个MY-THIRD函数？&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-12&quot;&gt;2.9 函数操作指针&lt;/h3&gt;

&lt;p&gt;当我们说一个对象（比如列表或者字符串）成为一个函数的输入的时候，其实这是不准确的。在计算机内部，每一个操作都是围绕指针来进行的，所以真实的输入不是对象本身，而是指向对象的指针。与之相同的，函数的返回值实际上也是一个指针。&lt;/p&gt;

&lt;p&gt;假设(THE BIG BOPPER)作为REST的输入，REST函数实际上接受的是第一个内存单位的一个指针。这个指针在下图中由波浪线表示，用波浪线来表示是因为这个指针不能明确的表示出来，换言之，这个指针并不存在于内存单元的内部，他存储在计算机的其他地方，计算机科学家们称作在一个寄存器或者在堆栈中。这些细节方面的事情我们现在还不用考虑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekwtb83sraj20ic03h3yg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;REST函数返回的结果是第二个内存单元的指针，也就是列表(BIG BOPPER)的第一个元素。那这个指针是从何而来？REST函数所做的事情就是把第一个元素的右半部分的指针提取出来，并作为结果返回。REST函数返回的是同一个内存单元链条的指针，并没有新的列表被REST函数创造出来。所有的操作仅仅是提取并返回一个函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekyav81bd4j20fn04zaa2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NOTE:上图中暂时的指向字符串THE的指针的意思是为了强调REST函数返回的结果是同一个列表的一部分。但是指向字符串THE的内存单元并不是REST 函数返回结果的一部分。&lt;/p&gt;

&lt;h4 id=&quot;carcdr&quot;&gt;2.10 CAR和CDR&lt;/h4&gt;

&lt;p&gt;到现在为止已经明白，每一个内存单元的一半都储存着一个指针，并且指向某个对象。每一半都有一个名字，左半部分的名字是CAR，后半部分叫做CDR。这些名字是早期计算的历史遗留。当Lisp在IBM704上第一次运行的时候，704太原始以至于还没用晶体管还在使用真空管。他的每一个寄存器都被分割成一些独立的组件，每两个组成地址部分和减量部分。那时候，CAR就是寄存器地址部分内容（Contents of Address portion of Register）的缩写，CDR就是寄存器减量部分内容（Contents of Decrement portion of Register）的缩写，虽然这些术语并没有应用在现代计算机的硬件上，但是Common Lisp部分由于历史原因任然使用CAR和CDR术语来指代内存单元。部分也是由于长格式名称的组成，比如CADR和CDDAR。&lt;/p&gt;

&lt;p&gt;CAR和CDR除了作为命名之外，也是内建Lisp函数的名字，作用是分别返回存单元的左半部分和右半部分指针。再看一下列表(THE BIG BOPPER)，当作为函数CAR的输入的时候，函数接受的并不是列表本身，而是第一个内存单元的指针。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekybu200h0j20k704wgln.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入CAR函数的内存单元，提取内存单元指针的CAR部分。所以CAR函数返回的是字符串THE的指针。那同样列表作为输入的时候CDR函数会输出什么呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekyc3t6tubj20fw07jgln.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入CDR函数的内存单元，提取内存单元指针的CDR部分。所以CAR函数返回的是列表(BIG BOPPER)的指针。从此例中可以看出，CAR和FIRST,CDR和REST的功能是相同的。Lisp程序员经常如此表述：FIRST返回列表的CAR,REST返回列表的CDR。&lt;/p&gt;

&lt;h5 id=&quot;cdr&quot;&gt;2.10.1 一个单元素列表的CDR&lt;/h5&gt;

&lt;p&gt;之前看到的列表（AARDVARK）和字符串AARDVARK不一样、列表是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekwlmkodswj205302wweb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然一个长度为1的列表在计算机内部表现为一个内存单元，那么这个长度为1的CDR就是一个长度为0的列表，NIL&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekych506aaj20dm07s0sr.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;列表((PHONE HOME))只有一个元素。请记住一个列表的元素只是最外层括号之内的对象，这些项目是由第一层次的内存单元指针指向决定的。这个列表的图示是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekycovbs29j2089056jrb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然CAR和CDR是从列表的内存单元中提取出特定的指针。那么列表((PHONE HOME))的CAR部分就是(PHONE HOME)。CDR部分就是NIL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekyctszkasj20g207kt8s.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.10 画出列表(((PHONE HOME)))的内存形式图，他有几层括号，CAR，CDR是什么？&lt;/li&gt;
  &lt;li&gt;2.11 画出列表(A (TOLL) ((CALL)))的内存形式图。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;carcdr-1&quot;&gt;2.10.2 CAR和CDR的组合&lt;/h5&gt;

&lt;p&gt;观察这样一个列表（FEE FIE FOE FUM），第一个元素是FEE。提取第二个元素的操作是将列表输入FIRST函数，之后再输入REST，或者以我们新的术语，先CDR之后CAR。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekz2lvbjlhj20d202twed.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果把函数名从左往右读出来，会先读出CDR然后读出CAR。既然CAR函数的输入就是CDR的输出，用英语说就是列表的CDR的CAR。在Lisp中CDR的CAR会被缩写成为CADR。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekz2lvbjlhj20d202twed.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果把A和D调换一下位置会发生什么？函数CADR是提取列表的CAR的CDR，列表(FEE FIE
FOE FUM)的CAR就是FEE，假如我们想要获得这个列表的CDR，那就会返回错误。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekz3e8zq1dj20h807vmx9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CDDAR函数返回列表的第三个元素。（如果对新的缩略词由困惑的话，请参考下面的发音指导）这些函数的名字体现那了这个函数的工作方式：CADDR就是提取列表的CDR的CDR的CAR。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekz3qslok9j20di03it8l.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;怎样理解CADDR是如何工作，你可以从右往左读出A和D的数目。列表(FEE FIE FOE FUM)作为输入，首先首先是CDR,输出就是(FIE FOE FUM)。然后再一次提取CDR，给出结果(FOE FUM)。最后再提取CAR，就得出了FOE。&lt;/p&gt;

&lt;p&gt;也有另一个角度来看待CADDR，首先是CDDR也就是提取CDR的CDR，或者说是REST的REST。列表(FEE FIE FOE FUM)的CDDR是(FOE FUM)。然后在提取CAR就是FOE。CADDR其实就是CDDR的CAR。&lt;/p&gt;

&lt;p&gt;Common Lisp提供了很多有关CAR，CDR内建函数，包括了四位AD的所有组合情况。CAADDR是内建的，但是CAADDAR就不是内建函数了。Lisp也提供了从FIRST到TENTH的内建函数定义。&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.12 什么样的C…R组合会返回列表的第四个元素？怎样读这样一个函数？&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;carcdr-2&quot;&gt;2.10.3 嵌套函数的CAR和CDR&lt;/h5&gt;

&lt;p&gt;CAR和CDR也可以像使用在普通列表上一样应用在嵌套列表上。让我们看看如何获取列表((BLUE CUBE) (RED PYRAMID))内部的组件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekz4hzaartj20fb058dfx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekz4jh3n3oj20iu0glq3u.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;列表的CAR就是(BLUE CUBE)。为了提取BLUE，我们必须提取CAR的CAR.这个CAAR函数的作用就是这个。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekz4mfnr64j20gc03s3yf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也有另一个角度来看待这个过程。嵌套列表的第一个元素是(BLUE CUBE)，所以CUBE就是列表的FIRST的SECOND。也就是CAR的CADR,等同于CADAR。&lt;/p&gt;

&lt;p&gt;现在我们来尝试获取字符串RED，RED是列表的SECOND的FIRST,也就是CADR的CAR。把两个名字融合到一起就是CAADR。具体的过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekz4xyzswmj20dx05eaa6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-15&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2.13 画出列表(((FUN)) (IN THE) (SUN))的到每一个字符串的具体过程，利用上图表示的倒三角形式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.14 使用列表((A B) (C D) (E F))作为输入，填空&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Function&lt;/th&gt;
      &lt;th&gt;Result&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CAR&lt;/td&gt;
      &lt;td&gt;（A B）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CDDR&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CADR&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CDAR&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CDDAR&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CDADDR&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;2.16 CAAR以列表（FRED NIL）作为输入时如何处理的？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nilcarcdr&quot;&gt;2.10.4 关于NIL的CAR和CDR&lt;/h4&gt;

&lt;p&gt;关于NIL有一个有趣的现实：NIL的CAR和CDR是被定义为NIL的。关于这一点为什么真么做可能会有一些让人疑惑。在Lisp的一些早期方言版本中，把NIL作为CAR和CDR的输入实际上会返回错误。但是经验显示，把NIL的CAR和CDR定义为NIL有一个很有用的结果，在后续章节中我们会有所介绍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekz7sre0vuj209d07ua9z.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然函数FIRST，SECOND，THIRD等等内部都是有CAR和CDR组成所定义的，单一需要解析的一个列表比较短的时候，那么返回的结果就是NIL。比如返回列表(DING ALING)的第三个元素，但是这个列表没有第三个元素，结果就是NIL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekz7ys9kq7j20bz0433yd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-16&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2.17 完成下列计算过程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekz807ceuoj20cr0ffaab.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekz810toipj20dq0fg3yp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/15/Ch-02-Lists-A/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/15/Ch-02-Lists-A/</guid>
        
        <category>Lisp</category>
        
        <category>CommonLisp</category>
        
        <category>翻译</category>
        
        
        <category>Lisp</category>
        
      </item>
    
      <item>
        <title>学习Lisp-第一章-函数和数据-B</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;第一章 函数和数据 下&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;1.9 函数的组合&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#add1&quot; id=&quot;markdown-toc-add1&quot;&gt;1.9.1 定义函数ADD1&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#add2&quot; id=&quot;markdown-toc-add2&quot;&gt;1.9.2 定义函数ADD2&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#twop&quot; id=&quot;markdown-toc-twop&quot;&gt;1.9.3 定义TWOP函数&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;练习题&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#onemorep&quot; id=&quot;markdown-toc-onemorep&quot;&gt;1.9.4 定义ONEMOREP函数&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;练习题&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#not&quot; id=&quot;markdown-toc-not&quot;&gt;1.10 NOT断言&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;1.11 反转一个断言&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;1.12 函数输入的个数&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#errors&quot; id=&quot;markdown-toc-errors&quot;&gt;1.13 错误（ERRORS）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;练习&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;本章概述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;复习题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;进阶话题&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#lisp&quot; id=&quot;markdown-toc-lisp&quot;&gt;1.14 Lisp的历史&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《Common Lisp 符号计算简单介绍》第一章 函数和数据 下半部分&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;第一章 函数和数据 下&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.9 函数的组合&lt;/h3&gt;

&lt;p&gt;到现在为止我们已经了解了许多Common Lisp的内建函数，这些内建函数通常被称为原始函数，或者原语。我们将会以丰富的组合方式使用这些内建函数来创建新的函数。&lt;/p&gt;

&lt;h4 id=&quot;add1&quot;&gt;1.9.1 定义函数ADD1&lt;/h4&gt;

&lt;p&gt;我们来定义一个函数来给它的输入加上1.已经存在原始函数满足条件：+函数将两个数字加在一起输出和的值。我们的ADD1函数将会取得一个输入，然后加1作为输出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvk0vxnk4j20b2061jrg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们已经定义好的ADD1函数可以用来给我们想要的任何数字加1。先画一个盒子然后附上名字ADD1，在提供一个输入，比如5：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvk2ykj1gj207h03hwec.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以看看这个函数内部是如何工作的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvk52dnpgj20bo062jrf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;add2&quot;&gt;1.9.2 定义函数ADD2&lt;/h4&gt;

&lt;p&gt;现在假设我们需要一个函数来个输入加上2.我们可以用定义ADD1同样的方式来定义ADD2。但是Lisp总是希望有多种方法来解决一个问题；有时候更会对寻找可选的方案着迷。例如，我们可以用两个ADD1来定义ADD2：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvk9puiu7j20dq06wmxd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一旦我们定义了ADD2，就可以给我们想要的任何数字加上2.而从ADD2的外部来看，我们无从得知是上述哪一种方案在内部被采用了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekvkb8z8btj207q03na9x.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是当我们探寻ADD2内部的时候，可以很明确的看到正在发生的事情，数字5流入第一个ADD1函数，产生6作为结果，然后6又流入第二个ADD1函数，之后的结果就是7.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvkdpmlkij20e2060wen.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们再往深处看，我们可以看见+函数在每一个ADD1函数的内部工作。：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekvkeycnxlj20j508dwf1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然这是我们现在所能达到的最深的层次，因为+函数已经是原始函数了。&lt;/p&gt;

&lt;h4 id=&quot;twop&quot;&gt;1.9.3 定义TWOP函数&lt;/h4&gt;

&lt;p&gt;我们也可以用新学习到的知识来定义一个自己的断言，其实断言也是输出结果为特殊类型的函数而已。断言是返回结果是T或者NIL的函数。这个TWOP断言是判断输入是不是2的定义如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekvkhkieoej20bb067wem.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一些使用TWOP函数的例子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekvkhkieoej20bb067wem.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;译者注：这里回顾一下，TWOP可以分成两部分来看，TWO和P，一般来说，断言是predicate的缩写，也就是说，这是一个断言函数，前半部分的two表示2，这是一个判断是不是2的断言。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;练习题&lt;/h4&gt;

&lt;p&gt;1.4定义一个从输入中减去2的函数SUB2。&lt;/p&gt;

&lt;p&gt;1.5说明如何使用ZEROP和SUB2还定义TWOP函数&lt;/p&gt;

&lt;p&gt;1.6HALF函数返回的是输入的一半的数字。用两种方式来定义HALF&lt;/p&gt;

&lt;p&gt;1.7定义一个MULTI-DIGIT-P断言，当输入大于9 的时候返回T&lt;/p&gt;

&lt;p&gt;1.8下图函数的功能是什么？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekvkhkieoej20bb067wem.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;onemorep&quot;&gt;1.9.4 定义ONEMOREP函数&lt;/h4&gt;

&lt;p&gt;我们来尝试定义一个双输入函数。一个ONEMOREP断言，用来测试第一个输入是不是比第二个输入大上1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvkl449w9j20et094jrp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;清楚ONEMOREP是如何运行的了吧？假如第一个输入比第二个输入大1，给第二个输入加上1将会使他们相等。在这种情况下，这个EQUAL断言将会返回T。换言之，假如第一个输入并不是比第二个输入大1，那么两个给EUQAL断言的输入就不是相等的，所以就会返回NIL，例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvkl449w9j20et094jrp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在你的脑子里（其实大声说出来也没关系），追溯上例的数据在ONEMOREP中的处理流程，你可能会这么描述：“第一个输入是7，第二个输入是6,6先输入到ADD1，输出了7,两个7输入到EQUAL函数，既然7和7是相等的，所以EQUAL函数的输出是T。所以T即使ONEMOREP的结果。”当然也可以从另一个角度来描述：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvkn69u6aj20gf08wq39.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于第二个例子你可能会这么说：“第一个输入是7，第二个输入是3,3输入ADD1函数，输出了一个4。7和4输入到EQUAL函数，既然4和7是不相等的，那么EQUAL的结果就是NIL，所以ONEMOREP的结果就是NIL。”。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;练习题&lt;/h4&gt;

&lt;p&gt;1.9定义一个断言TWOMOREP：假如第一个输入比第二个输入大2，则输出T。使用ADD2函数到定义中。&lt;/p&gt;

&lt;p&gt;1.10找到一个方法，使用SUB2替换ADD2函数来定义TWOMOREP。&lt;/p&gt;

&lt;p&gt;1.11定义一个AVERAGE函数，平均的的含义是两个数的和的一半。&lt;/p&gt;

&lt;p&gt;1.12定义一个MORE-THAN-HALF-P断言：如果第一个输入大于第二个输入的一半就返回T。&lt;/p&gt;

&lt;p&gt;1.13下图函数无论输入什么都会返回同一个结果，请问返回什么？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekvkozertcj20gv05rt8x.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;not&quot;&gt;1.10 NOT断言&lt;/h4&gt;

&lt;p&gt;NOT是一个对立断言：也就是会把yes变成no，把no变成yes。在Lisp术语中，意思就是说，输入是T，NOT就会返回NIL。而输入时NIL，NOT就会返回T。NOT的一个很好的特性就是结合一些其他的断言能够很方便地推导出他们的对立面；比如我们可以使用NOT和EQUAL结合来推导出不等于这个断言，或者通过NOT和ZEROP来推导出非零这个断言。我们将在下一节里看到这定义过程，首先来看一些NOT的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekvkqrwb4dj208x07ijrd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按照惯例，NIL在Lisp中是唯一表示no的方法，任何其他输入都会被认为是yes。所以在NOT函数中，只要不是输入NIL就会输出NIL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvksmsb3ij209m03lgli.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这不仅仅是一个无端端的惯例。将NIL定义为唯一的false表示，除了NIL之外的都被作为yes对待是非常有用处的。这个将会在后续章节作出解释。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;1.14 将下列计算过程的结果写明：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvkuc0nfpj207o07jweg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;1.11 反转一个断言&lt;/h4&gt;

&lt;p&gt;假设我们要定义一个断言来测试两个输入是否不相等，就是相当于相等的对立面。我们可以从EQUAL断言开始建立把他的结果作为NOT断言的输入，最后得到结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekvkxugj25j20ep068glv.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为这个NOT函数的关系，无论何时EQUAL函数得出T，NOT-EUQAL都会得出“NIL”的结论，相应的无论EQUAL函数得出NIL，NOT-EQUAL都会得出T。下例中，字符串PINK和GREEN是不同的，所以EUQAL输出NIL而NOT将其改变为T。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvl51fcpuj20hh05lt8y.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在下例中PINK和PINK是相同的，所以EQUAL输出T，NOT将其改变为NIL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekvl64mx3yj20h105kmxd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1.15 定义一个NOT-ONEP断言：当输入不是1的时候返回T&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.16 定义一个NOT-PLUSP断言：当输入不大于0的时候返回T&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.17 一些早期的Lisp方言是没有EVENP原语的：只有ODDP，说明如何使用ODDP来定义EVENP。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.18 在什么样的条件下，下例函数返回T？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d6a2535jw1ekvl76yptvj20ik05kweq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.19 在输入NIL的情况下，下例函数的结果是什么？如果输入时T呢？是不是所有的数据经过这个函数处理之后结果都不变？如果输入是RUTABAGA那结果是什么？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekvl853klqj20dk05omx9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.20 真值函数：输入和输出都是真值的函数，就是T和NIL。NOT就是一个真值函数。（虽然NOT接受除了T和NIL意外的输入，但是却只关心输入是不是true）；写一个XOR函数，异或真值函数，当输入一个是T，一个是NIL的时候输出T，当两个输入同时是T或者同时是NIL的时候输出NIL（提示：其实没有看上去那么难）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;1.12 函数输入的个数&lt;/h4&gt;

&lt;p&gt;一些函数的输入个数是固定的，比如ODDP，就要求一个输入，还有EQUAL必须是两个输入。但是有很多函数是可以接受不定数量的输入的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;比如数学运算函数+-*/就接受任何数量的输入。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekvla0z047j207v03iq2t.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了三个数相乘，就需要把前两个数先相乘，然后把所得的结果再和第三个数相乘，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekvlb50uv1j20fm078gls.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当-或者/收到两个以上输入的时候，结果就是由第一个输入依次被减（或者被除）被其余的输入。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d6a2535jw1ekvlc9432lj208507owei.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当只有一个输入的时候，-和/的操作室不一样的。-的操作是把输入取负，换言之，就是把正号改为负号或者反过来，通过0减去这个数字来实现。/的操作是用1除以输入的数字，也就是给出一个倒数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvm5a85m8j209d07yaa0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双输入的情况明显就是定义算术运算函数的情况。当多于或者少于两个输入的情况下，实际上是被转换成为两个输入的情况来处理。例如上例中的4的倒数就是一个1/4的除法运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvm6ootrwj20co064mx8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;errors&quot;&gt;1.13 错误（ERRORS）&lt;/h4&gt;

&lt;p&gt;虽然我们构建的函数系统十分简单，但是已有一些错误的类型存在于其中。给函数的输入时一个错误类型的时候就会报一个错误。例如，+函数可以加数字，但是不能加字符串：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvmb6349pj20ec038dft.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另一种错误就是给了函数太多或者太少的输入&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvmcekcp9j20d507it8y.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，错误的产生也有可能是因为一个函数不能按要求完成计算，比如当被要求某个数字除以0的时候就出现这种错误：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d6a2535jw1ekvmdi7kptj20cv03e748.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;学习分别错误是学习编程很重要的一部分，你不用怀疑会花费大量的时间来熟练这项技能。因为很少有程序是在第一次编写就回回完美运行的。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;练习&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;1.21 下列每一个函数有什么不妥？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d6a2535jw1ekvmf7m57qj20fu0iyaay.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;本章概述&lt;/h3&gt;

&lt;p&gt;在本章，学习了两种数据类型，数字和字符串。也学习了一些内建的函数来操作数据。&lt;/p&gt;

&lt;p&gt;断言是一种特殊类型的函数，根据输入的不同来使用T和NIL来回答问题。字符串NIL意思就是false，字符串T的意思即是True。实际上，在Lisp中，除了NIL之外都被看做是True。&lt;/p&gt;

&lt;p&gt;函数在使用之前必须先被定义。我们可以通过组合不同现有函数的方式来创造新的函数。一个特别的有效的方式就是通过NOT函数来到处本来的对立面，这个方法经常使用在程序设计中，NOT-EQUAL函数就是从EQUAL函数导出得来。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;复习题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1.22 所有的断言都是函数吗？所有的函数都是断言吗？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.23 本章介绍的断言之中哪一个没有后缀P？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.24 NUMBER是不是一个数字？SYMBOL是不是一个字符串？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.25 为什么FALSE在Lisp中表示真？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.26 True or False？
（a）所有的断言接受T或者NIL作为输入
（b）所有的断言把T或者NIL作为输出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1.27 举出一个例子，会引起EVENP的输入类型错误。举出一个例子会引起输入错误数字错误。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本章出现的函数：
数学运算函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ - * / ABS SQRT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本章出现的断言：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Predicates: NUMBERP, SYMBOLP, ZEROP, ODDP, EVENP, &amp;lt;, &amp;gt;, EQUAL, NOT.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-11&quot;&gt;进阶话题&lt;/h3&gt;

&lt;p&gt;在每一章的最后部分都有进阶话题章节，不但会介绍一些进阶的编程材料，而且会在更加光广阔的数学和逻辑层面来进一步介绍计算机编程。&lt;/p&gt;

&lt;p&gt;本章节可以选读。初学者或许希望跳过这第一个难关直接通读全书。之后的章节也是一样，在一些地方会有进阶话题的材料。这些地方都被清楚地标示出来，可以轻松回过头来找到再读。&lt;/p&gt;

&lt;h4 id=&quot;lisp&quot;&gt;1.14 Lisp的历史&lt;/h4&gt;

&lt;p&gt;Lisp的源起可以追溯到1956年，一个夏季的人工智能研究会议在达特茅斯大学举办。在这个会议上，John McCarthy学到了一个新的名词叫做表处理（List Processing），这个概念是由Allen Newellhe J.C.Shaw,Herbert Simon提出的。在50年代，大部分程序是由汇编语言来写的，是一种根据计算机硬件电路直接定义的语言，Newell，Shaw和Simon等人创造了一种更加抽象的语言，叫做IPL（Information Processing Language的缩写），来操作人工智能领域最重要的两个数据类型，字符串和列表。但是IPL的语法还是和汇编语言很相似（当然指一样糟糕）。&lt;/p&gt;

&lt;p&gt;另一方面，在1950年代FORTRAN语言已经被开发出来。专门设计为排序后的数字化计算的FORTRAN被广泛应用在科学计算中。Fortran可以实现让程序员编写像&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A=(X+Y)*Z
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的代数表达式来替代编写汇编语言的指令程序。一项全面的革新出现了，那就是程序员编写类似于数学表达式那样的代码，而计算机来负责把这些代码翻译成汇编语言。这项新的创意是的FORTRAN成为了强力的数值计算语言。而McCarthy则想要建立在字符计算上同样强力的语言。&lt;/p&gt;

&lt;p&gt;其中一个他提出的设想就是，在FORTRAN之上，建立一个列表处理的子程序集合来实现。这个想法被供职于IBM的Herbert Gelerntner和Carl Gerberich付诸实践，并且命名为FIPL（FORTRAN List Processing Language）。但是McCarthy他自己从IPL，FORTRAN和FLPL之中汲取灵感，在工作于达特茅斯大学和MIT的时候设计了LISP语言（LISt Processor）、Lisp的第一个版本在一台IBM704机器上被开发出来。&lt;/p&gt;

&lt;p&gt;Lisp 1.5是第一个被广泛使用的Lisp方言。《Lisp 1.5 编程手册》也有McCarthy等人在1962年推出。
到了1964年，Lisp已经跑在一些诸如装了MIT兼容时分系统的IBM7094机器上了。从而也成为了第一个解释型语言。DEC（Digital Equipment Corporation）在Lisp的发展历史上也起到了突出的作用，最先运行早期Lisp的计算机之一就是DEC的PDP-1。PDP-6，PDP-10（之后的DECSystem-20）计算机也都为了Lisp的优化而特别设计。&lt;/p&gt;

&lt;p&gt;60年代中期过后，Lisp实现开始出现分歧。MIT开发了MacLisp，而Bolt，Berank和Newman还有Xerox一起开发了InterLisp，标准Lisp 1.6是MacLisp的早期版本的一个分支。这些放眼中的每一个本质上都源自于Lisp 1.5，但是去都各自走向了不兼容的道路。&lt;/p&gt;

&lt;p&gt;在70年代，Guy Steelehe Gerald Suss定义了一种新的Lisp方言叫做Scheme，从Algol语言家族中获取一些优点，结合Lisp强力的语法和数据结构。而后Scheme的扩展方言开始发展更新，同步于Lisp的发展。&lt;/p&gt;

&lt;p&gt;到了80年代早期，事实上的互不兼容的Lisp实现已经有数十种，还有六七种主要的方言。于是由Scott Fahlman, Daniel Weinreb, David Moon, Guy Steele, and Richard Gabriel领导的项目Common Lisp应运而生，为的是整合现有方言的优点，融汇成一个紧密的整体。Common Lisp的第一个标准在1984年横空出世，而后1989年的修订版本也相继推出。Common Lisp很快就成为了包括学术向和工业向使用的Lisp的选择。其余的方言几乎销声匿迹。只剩下Scheme还在教育应用领域有着忠实的使用者。&lt;/p&gt;

&lt;p&gt;许多重要的编程思想在与Lisp的碰撞中首次出现。编译和解释函数的融合，垃圾回收机制，递归函数调用，代码级别的追踪和调试，还有语法制导编辑。时至今日，Lisp依然是函数式编程，面向对象编程和并发编程风格等前言领域的主要语言。&lt;/p&gt;

&lt;p&gt;更多关于Lisp历史的信息，请看之后McCarthy和Gabriel引述的扩展阅读章节&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/15/Ch-01-FunctionsAndData-B/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/15/Ch-01-FunctionsAndData-B/</guid>
        
        <category>Lisp</category>
        
        <category>CommonLisp</category>
        
        <category>翻译</category>
        
        
        <category>Lisp</category>
        
      </item>
    
      <item>
        <title>学习Lisp-第一章-函数和数据-A</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;第一章 函数和数据 上&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;1.1 导引&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;1.2 操作数字的函数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;1.3 三种数字类型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;1.4 输入的顺序是十分重要的&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;练习 1.1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#symbols&quot; id=&quot;markdown-toc-symbols&quot;&gt;1.5 字符串（SYMBOLS）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;练习 1.2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;1.6 特殊的字符串&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;1.7 一些简单的断言&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#equal&quot; id=&quot;markdown-toc-equal&quot;&gt;1.8 EQUAL断言&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;练习 1.3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《Common Lisp 符号计算简单介绍》第一章 函数和数据 上半部分&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;第一章 函数和数据 上&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1 导引&lt;/h3&gt;

&lt;p&gt;这一章讲通过一些内建的Lisp函数例子对函数和数据的表示法做一个概览。假如你已经有一些其他语言的编程经验，你可以在几分钟内跳读这一章。你会看到一些有字符组成的运算函数，一个Lisp的关键数据类型，一些以yes或者no为结果的断言。当你认为你已经完全领会了全部内容之后们可以阅读概述那一章节来检验一下自己是不是真的理解了。&lt;/p&gt;

&lt;p&gt;假如你是一个编程新手，那这一章就是专门为你设计的，我们将开始解释什么是函数什么是数据。数据的意思可以称作信息，例如数字，单词和一系列事物。你可以想象一个函数就像一个盒子，而数据从盒子的中间流过。函数以某一种方式操作数据，然后结果就是输出的数据。&lt;/p&gt;

&lt;p&gt;在介绍了Lisp提供的一些内建函数之后，我们将学习如何将现有的函数组合在一起创造出一个新的函数（其实这就是计算机编程的本质）。引述出一些十分有用的创造函数的技巧和方法。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.2 操作数字的函数&lt;/h3&gt;

&lt;p&gt;或许大家最熟悉的函数就是简单地数学运算函数，加减乘除。下图体现的就是两个数如何相加：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/8d6a2535gw1f8rri8ku52j20740353yc.jpg&quot; alt=&quot;加函数.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个函数的名字是“+”，我们可以用几种方式来描述，在上图中到底发生了什么。从数据的观点来看，数字2和3流入到函数中，然后数字5从函数中流出。从函数的观点来看，函数“+”接受数字2和3作为输入，然后产生5作为结果输出。从程序员的角度来看，我们调用或者说唤起函数“+”，输入是3和2，然后函数返回值5。这些都是用不同的方式讨论数据和程序是等同的；你将在本书的许多地方遇到这个观点。&lt;/p&gt;

&lt;p&gt;下表表示的就是Lisp函数对数字的操作：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;符号&lt;/th&gt;
      &lt;th&gt;意义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;计算出两个数加在一起的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;取得第一个数减去第二个数的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;计算两个数相乘得到的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;计算第一个数被第二个数除得到的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ABS&lt;/td&gt;
      &lt;td&gt;计算一个数的绝对值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SQRT&lt;/td&gt;
      &lt;td&gt;求一个数的根&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;让我们来看另一个数据流穿过函数的例子。ABS，输出绝对值的函数，顾名思义，正数不变，负数取反的函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d6a2535gw1f8rrj9vu4uj207a034q2s.jpg&quot; alt=&quot;ABS.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;数字-4输入到函数ABS，计算出来的绝对值作为结果输出4。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.3 三种数字类型&lt;/h3&gt;

&lt;p&gt;在本书中，我们打的交道最多的是正数（integers），就是所有的自然数字。Common Lisp也提供了许多其他种类的数字。应该了解的一种就是浮点数（floating point numbers）。一个浮点数总是会被写成带有一个十进制的小数点；例如，数字5会被写成5.0。这个SQRT函数一般来讲是返回一个浮点数作为结果，就算输入是整数的情况下也是。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rrkdqk3pj207o038wed.jpg&quot; alt=&quot;SQRT.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分数（ratio）是另一种数字形式。在便携式计算器中，1/2的表示常常是浮点数来表示的比如0.5。但是在Common Lisp中，我们也可以吧二分之一表示成1/2。Common Lisp把分数自动简化成为最小分母的形式；例如分数4/6,6/9，都会被简化成2/3。&lt;/p&gt;

&lt;p&gt;当我们调用一个运算函数，并输入一个整数的时候，Common Lisp通常将会产生一个整数形式或者分数形式的结果。假如我们的输入整数浮点数混合，结果就将会是一个浮点数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rruq4qigj208g06tq2z.jpg&quot; alt=&quot;分数浮点数.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.4 输入的顺序是十分重要的&lt;/h3&gt;

&lt;p&gt;按照惯例，当我们说函数的“第一个”输入的时候，我们指的是函数盒子左边最顶上的那个箭头。那“第二个”输入就是那个次高的箭头，以此类推。输入的顺序对于函数来说是非常重要的。举个例子，8除以2和2除以8是不一样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/8d6a2535gw1f8rrw0r1x8j207g0720sp.jpg&quot; alt=&quot;分数.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当8除以2的时候，结果是4，而2除以8的时候，结果是1/4。另外有一点，在这里的分数并不一定是小于1的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rrzctqlfj207j03adfp.jpg&quot; alt=&quot;大于1的分数.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;练习 1.1&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.1 下面有一些函数，但是缺失了程序的一部分，请填空&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/8d6a2535gw1f8rs3wul67j2076038web.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d6a2535gw1f8rs4cogcrj207f0eiwen.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加上一点点难度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rs55sijjj207k0703yg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/8d6a2535gw1f8rs5qs3hfj20by0ejjrk.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;symbols&quot;&gt;1.5 字符串（SYMBOLS）&lt;/h3&gt;

&lt;p&gt;字符串是Lisp中另一种类型的数据。大家会发现他们比数字会更有趣一些。字符串是典型的跟随英语单词来的（比如TUESDAY），还有词组（比如BUFFALO-BREATH），或者约定俗成的缩写（就像SQRT是“square root”的缩写）。字符串命名几乎包含了实际上所有的字母和数字的组合。加上一些特殊字符，比如连字符-。这里有一些Lisp字符串的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;X
ZORCH
BANANAS
R2D2
COMPUTER
WINDOW-WASHER
LORETTA
WARP-ENGINES
ABS
GARBANZO-BEANS
YAER-TO-DATE
BEEBOP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;甚至可以写得很长&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ANTIDISESTABLISHMENTARIANISM
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可能注意到了在这些字符串中包含了一些数字，比如“R2D2”，但是这不足以让他们成为数字。很重要的一件事情就是分清楚数字特别是整数和字符的区别，他们的定义会有帮助理解：&lt;/p&gt;

&lt;p&gt;整数：由“0”到“9”组成的序列，可以选择“+”或者“-”作为前缀。&lt;/p&gt;

&lt;p&gt;字符：任何字母，数字，和被允许使用的特殊字符（不包括数字）组成的序列。&lt;/p&gt;

&lt;p&gt;所以FOUR是一个字符串，而4就是一个整数，+4也是一个整数，但是+就是一个字符串。而且7-11也是一个字符串。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;练习 1.2&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.2 来辨别一下哪些是字符串，哪些是整数型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/8d6a2535gw1f8rs83oqkuj208g093jrx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;1.6 特殊的字符串&lt;/h3&gt;

&lt;p&gt;T Truth，真，表示 “yes”&lt;/p&gt;

&lt;p&gt;NIL 假, 表示 “no”&lt;/p&gt;

&lt;p&gt;T和NIL在Lisp中是基础不过的感念，以至于你问一个专业的Lisp程序员yesorno的问题，得到的回答往往不是英语，而是T和NIL。（“老王！去吃饭呗？”“NIL，刚吃了”）更重要的是说，详实的Lisp函数回答问题的答案也是T或者NIL。这样yesorno的问题被称作断言（predicates）。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;1.7 一些简单的断言&lt;/h3&gt;

&lt;p&gt;一个断言就是一个回答问题的函数。断言的输出是固定的，在回答yes的时候输出T，回答no的时候输出NIL。我们将要学习的第一个断言是判断输入是不是一个数字。名字叫做NUMBERP（读作“number-pee”，就是“Number predicate”的简写）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/8d6a2535gw1f8rt1gucy9j209x06xdfw.jpg&quot; alt=&quot;断言1.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相似的，断言SYMBOLP就是测试输入是不是一个字符串，是的话就返回T，不是的话就返回NIL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rt27opy3j209t03dglj.jpg&quot; alt=&quot;断言2.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/8d6a2535gw1f8rt2lciegj208x039jrb.jpg&quot; alt=&quot;断言3.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;断言ZEROP，EVENP和ODDP只接受数字作为输入，如果输入是0的，ZEROP返回T。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/8d6a2535gw1f8rt343qswj208d070q2z.jpg&quot; alt=&quot;ZEROP.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果输入是奇数的话，ODDP将会返回T，否则将会返回NIL。而断言EVENP怎是判断偶数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rt3mmxtuj20860amaa8.jpg&quot; alt=&quot;ODDP.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到现在为止，你应该注意到凡是后缀P的函数名一般都是断言。（“老王！饿P？”“T，饿爆了”）虽说不是所有断言都遵守这个规律，但是大部分是的。&lt;/p&gt;

&lt;p&gt;还有两个断言：&amp;lt; 返回T，如果第一个输入大于第二个输入。（这两个也是我们后缀P规律的第一个例外）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d6a2535gw1f8rt4h4plpj207q071t8o.jpg&quot; alt=&quot;大于小于.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;equal&quot;&gt;1.8 EQUAL断言&lt;/h3&gt;

&lt;p&gt;断言EQUAL是用来比较两个输入是不是相同。如果两个输入相同，EQUAL返回T，反之则返回NIL。在Common Lisp中的断言与EQUAL功能近乎相同的断言有EQ，EQL和 EQUALP,他们之间的区别还不会困扰我们，对于初学者，EQUAL是第一个需要掌握的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d6a2535gw1f8rt5ad9pxj209z077jrl.jpg&quot; alt=&quot;等于.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rt5o2id6j20ah037jrc.jpg&quot; alt=&quot;1.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;练习 1.3&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.3 填写计算之后的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8rt6t5iifj20b50i10t8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/8d6a2535gw1f8rt7al5d3j208206yt8q.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;附注：第一章比较长，（上）到这里经原始函数讲完了，（下）开始讲组合函数。&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/15/Ch-01-FunctionsAndData-A/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/15/Ch-01-FunctionsAndData-A/</guid>
        
        <category>Lisp</category>
        
        <category>CommonLisp</category>
        
        <category>翻译</category>
        
        
        <category>Lisp</category>
        
      </item>
    
      <item>
        <title>Spring MyBatis SpringMVC 框架基本整合</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;基本问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;事前准备&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;具体手顺&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;项目创建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;数据准备&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dao&quot; id=&quot;markdown-toc-dao&quot;&gt;DAO代码生成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mybatis&quot; id=&quot;markdown-toc-mybatis&quot;&gt;编辑MyBatis配置文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pomxml&quot; id=&quot;markdown-toc-pomxml&quot;&gt;添加pom.xml中的依赖&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#webxml&quot; id=&quot;markdown-toc-webxml&quot;&gt;配置web.xml文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ssmdemo-dispatcher-servletxml&quot; id=&quot;markdown-toc-ssmdemo-dispatcher-servletxml&quot;&gt;编辑ssmdemo-dispatcher-servlet.xml文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#userservice&quot; id=&quot;markdown-toc-userservice&quot;&gt;构建UserService接口和实现&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#controller&quot; id=&quot;markdown-toc-controller&quot;&gt;构建Controller&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring框架整合第三弹；
使用SSM框架搭建最基本的web service&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;基本问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如何做一个最基本的 web service&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSM框架怎么整合使用？最小集合的基本使用？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;事前准备&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;本地的MySQL服务创建配置OK&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;具体手顺&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;项目创建&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用maven进行构建，创建新项目，使用模板webapp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;项目Github地址：&lt;a href=&quot;https://github.com/AllenChyou/ssmdemo&quot;&gt;ssmdemo&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;数据准备&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建数据库表结构&lt;/p&gt;

    &lt;p&gt;文件：src/main/resources/sql/schema.sql&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dao&quot;&gt;DAO代码生成&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用mybatis-generator根据数据库生成代码&lt;/p&gt;

    &lt;p&gt;文件：src/main/resources/generatorConfig.xml&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加生成代码用的maven插件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成之后的目录结构&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/8d6a2535gw1f8qpzx3t9ij208u0e2wfw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;mybatis&quot;&gt;编辑MyBatis配置文件&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;文件：src/main/resources/mybatis-config.xml&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pomxml&quot;&gt;添加pom.xml中的依赖&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文件：pom.xml&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;依赖包括mybatis相关和spring相关包&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;maven-jetty-plugin插件是项目运行的web容器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;webxml&quot;&gt;配置web.xml文件&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;容器根据这个文件加载context文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ssmdemo-dispatcher-servletxml&quot;&gt;编辑ssmdemo-dispatcher-servlet.xml文件&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个文件的名字是固定的，项目名称-dispatcher-servlet.xml&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;userservice&quot;&gt;构建UserService接口和实现&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UserService接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UserServiceImpl实现&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;controller&quot;&gt;构建Controller&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;UserController实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;小结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;最最基本的SSM搭建，只是跑通了，web service起来了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有待完善的点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;只有查询方法，CRUD的添加有待完成&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据交互没有JSON格式化，只是文本&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 13 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/13/springmybatisspringmvcdemo/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/13/springmybatisspringmvcdemo/</guid>
        
        <category>spring</category>
        
        <category>mybatis</category>
        
        <category>springmvc</category>
        
        <category>webservice</category>
        
        <category>Java</category>
        
        <category>后端</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>SpringMVC使用maven jetty插件运行</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;基本问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;事前准备&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pomxml&quot; id=&quot;markdown-toc-pomxml&quot;&gt;pom.xml中的配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#webxml&quot; id=&quot;markdown-toc-webxml&quot;&gt;配置web.xml文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mvc-dispatcher-servletxml&quot; id=&quot;markdown-toc-mvc-dispatcher-servletxml&quot;&gt;配置mvc-dispatcher-servlet.xml文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#controller&quot; id=&quot;markdown-toc-controller&quot;&gt;新建Controller&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;运行服务&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring框架整合第二弹；
SpringMVC单独使用maven-jetty-plugin运行服务&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;基本问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如何搭建一个可用的本地测试server？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎么使用SpringMVC开发一个API？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;事前准备&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;maven webapp项目创建&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完成后的文件布局&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/8d6a2535gw1f8qh78xqt5j20930abdh2.jpg&quot; alt=&quot;文件布局&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pomxml&quot;&gt;pom.xml中的配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;添加property节点，统一管理spring那么多包的版本&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;spring.version&amp;gt;4.0.2.RELEASE&amp;lt;/spring.version&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;添加Spring相关依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;添加maven-jetty-plugin插件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;plugins&amp;gt;
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.eclipse.jetty&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jetty-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;9.2.13.v20150730&amp;lt;/version&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;webxml&quot;&gt;配置web.xml文件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这个文件是webapp的配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE web-app PUBLIC
        &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;web-app&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;display-name&amp;gt;&lt;/span&gt;Archetype Created Web Application&lt;span class=&quot;nt&quot;&gt;&amp;lt;/display-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context-param&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;/WEB-INF/mvc-dispatcher-servlet.xml&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;listener&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;listener-class&amp;gt;&lt;/span&gt;org.springframework.web.context.ContextLoaderListener&lt;span class=&quot;nt&quot;&gt;&amp;lt;/listener-class&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/listener&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;mvc-dispatcher&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;load-on-startup&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/load-on-startup&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;mvc-dispatcher&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mvc-dispatcher-servletxml&quot;&gt;配置mvc-dispatcher-servlet.xml文件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;springmvc的配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:mvc=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.zzj.controller&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:annotation-driven/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;controller&quot;&gt;新建Controller&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;需要用注解来驱动&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.zzj.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/**
 * Created by zhangzj on 2016/10/13.
 */

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)
    public ResponseEntity getUser(){
        return new ResponseEntity(&quot;user body&quot;, HttpStatus.OK);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;运行服务&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在项目目录下运行命令&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mvn jetty:run
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;小结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SpringMVC作用貌似是根据请求路径反应的这个一个东西，注解驱动很有趣&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;maven-jetty-plugin内置的webserver，部署测试很方便&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 13 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/13/springmvcandjetty/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/13/springmvcandjetty/</guid>
        
        <category>spring</category>
        
        <category>springmvc</category>
        
        <category>maven-jetty-plugin</category>
        
        
        <category>spring</category>
        
        <category>maven-jetty-plugin</category>
        
      </item>
    
      <item>
        <title>Git的基本概念和原理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;基本问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;通识概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git&quot; id=&quot;markdown-toc-git&quot;&gt;Git术语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Git的一些基本概念，关键词，术语, 原理&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;基本问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;git范围内有哪些基本概念需要掌握？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;git的基本原理是什么？实现思路？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;通识概念&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;版本控制系统&lt;/p&gt;

    &lt;p&gt;有变更预期的数据，在时间线上的离散版本，就需要一个总的记录&lt;/p&gt;

    &lt;p&gt;最原始的方式就是不断的backup，那也是版本控制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;集中式版本控制和分布式版本控制&lt;/p&gt;

    &lt;p&gt;集中式：CVS， SVN； 分布式：Git&lt;/p&gt;

    &lt;p&gt;分布式即是copy的是全部的数据，每一份都是完整的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;git&quot;&gt;Git术语&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;工作区&lt;/p&gt;

    &lt;p&gt;文件修改后保存的区域，需要使用 git add 命令&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;暂存区 stage&lt;/p&gt;

    &lt;p&gt;文件被修改后保存的区域，等待commit的区域&lt;/p&gt;

    &lt;p&gt;暂存区是工作区和版本库之间的中间状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提交ID&lt;/p&gt;

    &lt;p&gt;40位十六进制数字，实际上是SHA1哈希值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 12 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://allenchyou.github.io/2016/10/12/gitIntroduction/</link>
        <guid isPermaLink="true">http://allenchyou.github.io/2016/10/12/gitIntroduction/</guid>
        
        <category>git</category>
        
        
        <category>git</category>
        
      </item>
    
  </channel>
</rss>
