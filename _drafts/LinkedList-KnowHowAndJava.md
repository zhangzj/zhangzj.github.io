---
layout: post
title: "链表主题理解"
categories: 算法与数据结构
description: 基本数据结构，有关链表的主题阅读和信息整理，对链表的基本理解和基本实现
tags: 数据结构 算法 Java
---

* content
{:toc}

链表的主题归纳

信息来源：
- 维基百科；
- 啊哈！算法




**基本概念**

链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。

使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。

链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的存取和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。

**为什么需要链表**

在存储一大波数据的时候，通常使用的是数组，但是数组有时候不够灵活，比如一组排好序的数组，需要插入一个元素，那就需要后面的元素依次往后挪动一位，这其实很麻烦

![](http://ww1.sinaimg.cn/large/8d6a2535jw1f9amszozjdj207j046jrn.jpg)

反观链表那就会快很多，实际上不需要移动大量的元素就可以做到

![](http://ww2.sinaimg.cn/large/8d6a2535jw1f9amvq63znj20e90140so.jpg)
![](http://ww1.sinaimg.cn/large/8d6a2535jw1f9amwdb0l5j20eb01q0sq.jpg)

链表的优点在于插入和删除节点十分方便，但是顺序访问效率就比较差

### 链表类型

链表有多种不同的类型，单向的双向的和循环链表

#### 单向链表 单链表

单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始。

![](http://ww2.sinaimg.cn/large/8d6a2535jw1f9adyl5b17j20ed04qglq.jpg)

单向链表的数据结构可以分为两部分：数据域和指针域，数据域存储数据，指针域指向下一个储存节点的地址

![](http://ww2.sinaimg.cn/large/8d6a2535jw1f9adz57lqcj20mo02at8u.jpg)

单链表可以细分成**动态单链表**和**静态单链表**

#### 双向链表 双链表

双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

![](http://ww3.sinaimg.cn/large/8d6a2535jw1f9aml7i72aj20xw02a0t4.jpg)

#### 循环链表

循环链表是一种链式存储结构，它的最后一个结点指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表的操作和单链表的操作基本一致，差别仅仅在于算法中的循环条件有所不同

![](http://ww3.sinaimg.cn/large/8d6a2535jw1f9amn5pekxj20jg03caa7.jpg)

#### 块状链表

块状链表本身是一个链表，但是链表储存的并不是一般的数据，而是由这些数据组成的顺序表。

### 链表的应用

链表用来构建许多其它数据结构，如堆栈，队列和他们的衍生。
节点的数据域也可以成为另一个链表。通过这种手段，我们可以用列表来构建许多链性数据结构；这个实例产生于Lisp编程语言，在Lisp中链表是初级数据结构，并且现在成为了常见的基础编程模式。 有时候，链表用来生成联合数组，在这种情况下我们称之为联合数列。这种情况下用链表会优于其它数据结构，如自平对分查找树（self-balancing binary search trees）甚至是一些小的数据集合。不管怎样，一些时候一个链表在这样一个树中建立一个节点子集，并且以此来更有效率地转换这个集合。

### 链表的实现

#### 实现一：C语言

使用指针和动态分配内存函数malloc实现单链表

首先我们需要一个节点的模型，使用C语言的结构体实现，包括一个数据和指向下一个后继节点的指针

```
struct node {
    int data;
    struct node *next;
};
```

而后我们需要一个头指针来表示链表的开始，也是一个node节点，叫做head，一开始链表是空的，head即为空


```
struct node *head;
head = NULL;
```

创建第一个节点，并指向临时指针p

```
struct node *p;
p = (struct node *)malloc(sizeof(struct node));
```

接下来设定p的数据和后继节点，后面没有元素，所以后继指针是空

```
scanf("%d", &a);
p->data = a;
p->next = NULL;
```

![](http://ww1.sinaimg.cn/large/8d6a2535jw1f9and4xzw6j204i02pdfn.jpg)

完整代码

```
#include <stdio.h>
#include <stdlib.h>
//这里创建一个结构体用来表示链表的结点类型 struct node
{
int data;
    struct node *next;
};
int main() {
struct node *head,*p,*q,*t; int i,n,a;
scanf("%d",&n);
head = NULL;//头指针初始为空 for(i=1;i<=n;i++)//循环读入n个数 {
scanf("%d",&a); //动态申请一个空间,用来存放一个结点,并用临时指针p指向这个结点
p=(struct node *)malloc(sizeof(struct node)); p->data=a;//将数据存储到当前结点的data域中 p->next=NULL;//设置当前结点的后继指针指向空,也就是当前结点的下一个结点为空 if(head==NULL)
head=p;//如果这是第一个创建的结点,则将头指针指向这个结点 else
q->next=p;//如果不是第一个创建的结点,则将上一个结点的后继指针指向当前结点
q=p;//指针q也指向当前结点
}
scanf("%d",&a);//读入待插入的数 t=head;//从链表头部开始遍历 while(t!=NULL)//当没有到达链表尾部的时候循环 {
if(t->next->data > a)//如果当前结点下一个结点的值大于待插入数,将数插入到中间 {
  用来存放新增结点
p=(struct node *)malloc(sizeof(struct node));//动态申请一个空间,
p->data=a; p->next=t->next;//新增结点的后继指针指向当前结点的后继指针所指向的结点
t->next=p;//当前结点的后继指针指向新增结点
break;//插入完毕退出循环 }
t=t->next;//继续下一个结点 }
//输出链表中的所有数 t=head; while(t!=NULL)
{
        printf("%d ",t->data);
t=t->next;//继续下一个结点 }
    getchar();getchar();
return 0; }
```
